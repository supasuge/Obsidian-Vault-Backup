## Table of Contents

  - [Table of Contents](#Table\of\Contents)
      - [Instructions](#Instructions)
  - [Step](#Step)
    - [gdb](#gdb)
          - [Step Once](#Step\Once)
      - [Step Count](#Step\Count)

## Table of Contents

      - [Instructions](#Instructions)
  - [Step](#Step)
    - [gdb](#gdb)
          - [Step Once](#Step\Once)
      - [Step Count](#Step\Count)


|Step|Description|
|---|---|
|`Break`|Setting breakpoints at various points of interest|
|`Examine`|Running the program and examining the state of the program at these points|
|`Step`|Moving through the program to examine how it acts with each instruction and with user input|
|`Modify`|Modify values in specific registers or addresses at specific breakpoints, to study how it would affect the execution|



- First step of debugging is to stop the execution at a specific location when particular condition is met. This helps us in examinging the state of the proram and the value of the registers at that point
- `breakpoints` allow us to stop the program at certain conditions

`run` or `r` will run the program.

To manually examine any of the addresses or registers or examine any other, we can use the `x` command in the format of `x/FMT ADDRESS`, as `help x` would tell us. The `ADDRESS` is the address or register we want to examine, while `FMT` is the examine format. The examine format `FMT` can have three parts:

|Argument|Description|Example|
|---|---|---|
|`Count`|The number of times we want to repeat the examine|`2`, `3`, `10`|
|`Format`|The format we want the result to be represented in|`x(hex)`, `s(string)`, `i(instruction)`|
|`Size`|The size of memory we want to examine|`b(byte)`, `h(halfword)`, `w(word)`, `g(giant, 8 bytes)`|

#### Instructions

For example, if we wanted to examine the next four instructions in line, we will have to examine the `$rip` register (which holds the address of the next instruction), and use `4` for the `count`, `i` for the `format`, and `g` for the `size` (for 8-bytes or 64-bits). So, the final examine command would be `x/4ig $rip`, as follows:

Instructions

```shell-session
gef➤  x/4ig $rip
```
---

## Step

The third step of debugging is `stepping` through the program one instruction or line of code at a time. As we can see, we are currently at the very first instruction in our `helloWorld` program:

### gdb
###### Step Once
```
gef-> s 1
─────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400ffe                  add    BYTE PTR [rax], al
 →   0x401000 <_start+0>       mov    eax, 0x1
     0x401005 <_start+5>       mov    edi, 0x1
```

`step` or `si` command will step through the assembly one by one, `s` command will let you see the next instruction.
```bash
gef> si
```

#### Step Count

Similarly to examine, we can repeat the `si` command by adding a number after it. For example, if we wanted to move 3 steps to reach the `syscall` instruction, we can do so as follows:

gdb

gef➤  si 3
0x0000000000401019 in _start ()

Tip: You can hit the `return`/`enter` empty in order to repeat the last command. Try hitting it at this stage, and you should make another 3 steps, and break at the other `syscall` instruction.




| Description | 64-bit Register | 8-bit Register |
| :-: | :-: | :-: |
| Syscall Number/Ret value | `rax` | `al` |
| Callee Saved | `rbx` | `bl` |
| 1st arg | `rdi` | `dil` |
| 2nd arg | `rsi` | `sil` |
| 3rd arg | `rdx` | `dl` |
| 4th arg - Loop Counter | `rcx` | `cl` |
| 5th arg | `r8` | `r8b` |


| **Pointer Registers**| 64-bit | 8-bit |
| :-: | :-: | :-: |
| Base Stack Pointer | `rbp` | `bpl` |
| Current/Top Stack pointer | `rsp` | `spl` |
| Instruction Pointer 'call only' | `rip` | `ipl` |



| Command | Description |
| :----: | :----: |
| `gdb -q ./helloWorld` | Open binary in  gdb |
| `info functions` | View binary functions |
| `info variables` | View binary variables |
| `registers` | View registers |
| `disas _start` | Disassemble label/function |
| `b _start` | Break label/function |
| `b *0x401000` | break address |
| `r` | Run the binary |
| `x/4xg $rip` | Examine register "`x/`" count-format-size $register |
| `r` | Run the binary |
| `si` | Step to the next instruction |
| `s` | Step to the next line of code |
| `ni` | Step to the next function |
| `c` | Continue to the next break point |
| `patch string 0x402000 "Patched!\\x0a"` |  |