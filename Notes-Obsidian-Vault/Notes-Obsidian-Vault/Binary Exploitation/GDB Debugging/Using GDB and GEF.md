## Table of Contents

  - [Table of Contents](#Table\of\Contents)
        - [Installation](#Installation)
          - [Terms](#Terms)
      - [Functions](#Functions)
        - [Variables](#Variables)
  - [Disassemble](#Disassemble)
- [Debugging with GDB](#debugging\with\gdb)
  - [Setting Breakpoints and why](#Setting\Breakpoints\and\why)
    - [Examine](#Examine)
    - [Breakpoints](#Breakpoints)
  - [Examine](#Examine)
        - [Manual Examination](#Manual\Examination)
  - [Instructions](#Instructions)

## Table of Contents

        - [Installation](#Installation)
          - [Terms](#Terms)
      - [Functions](#Functions)
        - [Variables](#Variables)
  - [Disassemble](#Disassemble)
- [Debugging with GDB](#debugging\with\gdb)
  - [Setting Breakpoints and why](#Setting\Breakpoints\and\why)
    - [Examine](#Examine)
    - [Breakpoints](#Breakpoints)
  - [Examine](#Examine)
        - [Manual Examination](#Manual\Examination)
  - [Instructions](#Instructions)

#GNU #gdb #debugging #assembly #exploit
#GEF #reverseengineering
##### Installation
```bash
sudo apt-get update; sudo apt-get upgrade -y; sudo apt-get install gdb
```

One of the great features of `GDB` is its support for third-party plugins. An excellent plugin that is well maintained and has good documentation is [GEF](https://github.com/hugsy/gef). GEF is a free and open-source GDB plugin that is built precisely for reverse engineering and binary exploitation. This fact makes it a great tool to learn.

To add GEF to GDB, we can use the following commands:
\[`getgef.sh`]
```shell
#!/bin/bash
wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py
echo source ~/.gdbinit-gef.py >> ~/.gdbinit
```
`chmod u+x getgef.sh && ./getgef.sh`
https://hugsy.github.io/gef/
###### Terms


#### Functions

To start, we will use the `info` command to check which `functions` are defined within the binary:

  Functions

```shell
gef➤  info functions

All defined functions:

Non-debugging symbols:
0x0000000000401000  _start
```


#variables #gdb #gef 
##### Variables
```bash
gef> info variables

All defined variables:

Non-debugging symbols:
0x0000000000402000  message
0x0000000000402012  __bss_start
0x0000000000402012  _edata
0x0000000000402018  _end
```


## Disassemble

To view the instructions within a specific function, we can use the `disassemble` or `disas` command along with the function name, as follows:

  
Variables

```shell
gef➤  disas _start

Dump of assembler code for function _start:
   0x0000000000401000 <+0>:	mov    eax,0x1
   0x0000000000401005 <+5>:	mov    edi,0x1
   0x000000000040100a <+10>:	movabs rsi,0x402000
   0x0000000000401014 <+20>:	mov    edx,0x12
   0x0000000000401019 <+25>:	syscall
   0x000000000040101b <+27>:	mov    eax,0x3c
   0x0000000000401020 <+32>:	mov    edi,0x0
   0x0000000000401025 <+37>:	syscall
End of assembler dump.
```


You may notice through debugging that some memory addresses are in the form of `0x00000000004xxxxx`, rather than their raw address in memory `0xffffffffaa8a25ff`. This is due to `$rip-relative addressing` in Position-Independent Executables `PIE`, in which the memory addresses are used relative to their distance from the instruction pointer `$rip` within the program's own Virtual RAM, rather than using raw memory addresses. This feature may be disabled to reduce the risk of binary exploitation.


# Debugging with GDB

`break` : Set breakpoints at various points of interest.
`examine`: Running the program and examining the state of the program at these points.
`step`: Moving through the program to examine how it acts with each instruction and with use input
`modify`: Modify values in specific registers or addresses at specific breakpoints, to study it would affect the execution


## Setting Breakpoints and why
- Set breakpoints: `b` or `break` <\address or function to set abreakpoint\> 
`breakpoints` stop the execution at a certain location specified, or when a particular condition occurs. 
- Beneficial for examining the value of registers at that point in the program.
- Allows us to stop the programs execution at that point to step into each instuction.
To follow instructions run by the program:
```gef

Breakpoint 1 at 0x401000
gef➤  r
Starting program: ./helloWorld 
Breakpoint 1, 0x0000000000401000 in _start ()
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x0               
$rbx   : 0x0               
$rcx   : 0x0               
$rdx   : 0x0               
$rsp   : 0x00007fffffffe310  →  0x0000000000000001
$rbp   : 0x0               
$rsi   : 0x0               
$rdi   : 0x0               
$rip   : 0x0000000000401000  →  <_start+0> mov eax, 0x1
...SNIP...
───────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe310│+0x0000: 0x0000000000000001	 ← $rsp
0x00007fffffffe318│+0x0008: 0x00007fffffffe5a0  →  "./helloWorld"
...SNIP...
─────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400ffa                  add    BYTE PTR [rax], al
     0x400ffc                  add    BYTE PTR [rax], al
     0x400ffe                  add    BYTE PTR [rax], al
 →   0x401000 <_start+0>       mov    eax, 0x1
     0x401005 <_start+5>       mov    edi, 0x1
     0x40100a <_start+10>      movabs rsi, 0x402000
     0x401014 <_start+20>      mov    edx, 0x12
     0x401019 <_start+25>      syscall 
     0x40101b <_start+27>      mov    eax, 0x3c
─────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "helloWorld", stopped 0x401000 in _start (), reason: BREAKPOINT
───────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x401000 → _start()```

```
If we want to set a breakpoint at a certain address, like `_start+10`, we can either `b *_start+10` or `b *0x40100a`:

```shell-session
gef➤  b *0x40100a
Breakpoint 1 at 0x40100a
```


The `*` tells `GDB` to break at the instruction stored in `0x40100a`.

If we want to see what breakpoints we have at any point of the execution, we can use the `info breakpoint` command. We can also `disable`, `enable`, or `delete` any breakpoint. Furthermore, GDB also supports setting conditional breaks that stop the execution when a specific condition is met.
### Examine
| Decimal | Binary    | Octal | Hex | ASCII |
|---------|-----------|-------|-----|-------|
| 0       | 00000000  | 000   | 00  | NUL   |
| 1       | 00000001  | 001   | 01  | SOH   |
| 2       | 00000010  | 002   | 02  | STX   |
| 3       | 00000011  | 003   | 03  | ETX   |
| 4       | 00000100  | 004   | 04  | EOT   |
| 5       | 00000101  | 005   | 05  | ENQ   |
| 6       | 00000110  | 006   | 06  | ACK   |
| 7       | 00000111  | 007   | 07  | BEL   |
| 8       | 00001000  | 010   | 08  | BS    |
| 9       | 00001001  | 011   | 09  | HT    |
| 10      | 00001010  | 012   | 0A  | LF    |
| 11      | 00001011  | 013   | 0B  | VT    |
| 12      | 00001100  | 014   | 0C  | FF    |
| 13      | 00001101  | 015   | 0D  | CR    |
| 14      | 00001110  | 016   | 0E  | SO    |
| 15      | 00001111  | 017   | 0F  | SI    |
| 16      | 00010000  | 020   | 10  | DLE   |
| 17      | 00010001  | 021   | 11  | DC1   |
| 18      | 00010010  | 022   | 12  | DC2   |
| 19      | 00010011  | 023   | 13  | DC3   |
| 20      | 00010100  | 024   | 14  | DC4   |
| 21      | 00010101  | 025   | 15  | NAK   |
| 22      | 00010110  | 026   | 16  | SYN   |
| 23      | 00010111  | 027   | 17  | ETB   |
| 24      | 00011000  | 030   | 18  | CAN   |
| 25      | 00011001  | 031   | 19  | EM    |
| 26      | 00011010  | 032   | 1A  | SUB   |
| 27      | 00011011  | 033   | 1B  | ESC   |
| 28      | 00011100  | 034   | 1C  | FS    |
| 29      | 00011101  | 035   | 1D  | GS    |
| 30      | 00011110  | 036   | 1E  | RS    |
| 31      | 00011111  | 037   | 1F  | US    |
| 32      | 00100000  | 040   | 20  | SP    |
| 33      | 00100001  | 041   | 21  | !     |
| 34      | 00100010  | 042   | 22  | "     |
| 35      | 00100011  | 043   | 23  | #     |
| 36      | 00100100  | 044   | 24  | $     |
| 37      | 00100101  | 045   | 25  | %     |
| 38      | 00100110  | 046   | 26  | &     |
| 39      | 00100111  | 047   | 27  | '     |
| 40      | 00101000  | 050   | 28  | (     |
| 41      | 00101001  | 051   | 

### Breakpoints
`break` OR `b`

Ex:
```shell-session
gef➤  b _start

Breakpoint 1 at 0x401000
```

```
ef➤  b *0x401010a
Breakpoint 2 at 0x401010a
gef➤  
```

If programming is running adn you want to set another breakpoint like `b *0x401005` in order to continue to that breakpoint, we should use the `continue` or `c` command. `run`, `r` will run the program from the start. This can be useful to skip loops.

- To see what Breakpoints are set at anypoint of the execution, use the `info breakpoint` command.
- can also `enable`, `disable`, `delete` any given breakpoint. 

## Examine
`GEF` automatically gives lots of helpful information when we hit the breakpoint. 
- `GEF` automates many steps that we usually take at every breakpoint, like examining the registers, the stack, and the current assembly instructions.

##### Manual Examination
`x/FMT address` 

`count`: Number of times to repeat the examine
`format`: The format we want the result to be represented in.
	`x(hex), s(string), i(instruction)`
`size`: The size of the memory we want to examine.
	`b(byte), h(halfword), w(word), g(giant, 8bytes)`


## Instructions
If we want to examine the next four instructions in line, we will have to examine the `$rip` register. 
- This hold the address of the next instruction
	- Use `4` for the `count`, `i` for the `format`, `g` for the `size` (*8-bytes, 64-bits*)
```bash
x/4ig $rip
```
This will get the following four instructions as expected.



























