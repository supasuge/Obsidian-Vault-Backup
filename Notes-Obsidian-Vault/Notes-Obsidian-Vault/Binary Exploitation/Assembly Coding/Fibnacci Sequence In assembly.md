## Table of Contents

  - [Table of Contents](#Table\of\Contents)
  - [Importance](#Importance)
          - [Golden ration](#Golden\ration)
- [Data Movement](#data\movement)
    - [Moving Data](#Moving\Data)
    - [Loading Data](#Loading\Data)
      - [Moving Pointer Values](#Moving\Pointer\Values)
    - [Loading Value Pointers](#Loading\Value\Pointers)

## Table of Contents

  - [Importance](#Importance)
          - [Golden ration](#Golden\ration)
- [Data Movement](#data\movement)
    - [Moving Data](#Moving\Data)
    - [Loading Data](#Loading\Data)
      - [Moving Pointer Values](#Moving\Pointer\Values)
    - [Loading Value Pointers](#Loading\Value\Pointers)

Fibonacci Sequence is as follows:

$F^n=F^(n-1) +F^(n-2)$
For example, if we start with `F0=0` and `F1=1`, then F2 is `F1 + F0`, which is `F2 = 1 + 0 -> 1`.  
Following the same formula, F3 is `F3=1+1=2`, F4 is `F4 = 2 + 1 -> 3`, and so on.

## Importance
###### Golden ration
- Handy in art
- Math
- Physics
- Computer Science
- `finance`
# Data Movement
`mov` - Move data or load immediate data
	`mov rax, 1` -> `rax=1`
`lea` - Load an address pointing to the value
	`lea rax, [rsp+5]` -> `rax = rsp+5`
`xchg` - Swap data between two registers or addresses
	`xchg rax, rbx` -> `rax=rbx, rbx = rax`


### Moving Data
Use the `mov` instruction.
....

Load the values $F^0$ and $F^1$


```nasm
global _start

section .text
_start:
	mov rax, 0
	mov rbx, 1
```


ow, let's assemble this code and run it with `gdb` to see how the `mov` instruction works in action:

gdb

```
$ ./assembler.sh fib.s -g
gef➤  b _start
Breakpoint 1 at 0x401000
gef➤  r
```

### Loading Data

Load immediate data using the `mov` instruction... Ex:
- Load value of `1` into `rax` register using the `mov rax, 1` instruction. We have to remember `the size of the loaded data depends on the size of the destiantion register`For example, in the above `mov rax, 1` instruction, since we used the 64-bit register `rax`, it will be moving a 64-bit representation of the number `1` (i.e. `0x00000001`), which is not very efficient.
- `objdump` 

```nasm
global _start

section .text
_start:
	mov rax, 0
	mov rbx, 1
	mov bl, 1
```
- **objdump**
Now let's assemble it and view its shellcode with `objdump`

```bash
nasm -f elf64 fib.s && objdump -M intel -d fib.o
```



We can see that the shellcode of the first instruction is more than double the size of the last instruction.

`This understanding will become very handy when writing shellcodes.`

```bash
-[~/…/HTBSTUFF/ACADEMY/Assembly/disDay2]
└─$ nasm -f elf64 fib.s && objdump -M intel -d fib.o

fib.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <_start>:
   0:   b8 00 00 00 00          mov    eax,0x0
   5:   bb 01 00 00 00          mov    ebx,0x1
   a:   b3 01                   mov    bl,0x1
```

`This understanding will become very handy when writing shellcodes.`

Let us modify our code to use sub-registers to make it more efficient:

```nasm
global  _start

section .text
_start:
    mov al, 0
    mov bl, 1
```

The `xchg` instruction will swap the data between the two registers. Try adding `xchg rax, rbx` to the end of the code, assemble it, and then run it through `gdb` to see how it works.
#### Moving Pointer Values

We can see that the `rsp` register holds the final value of `0x1`, and its immediate value is a pointer address to `0x1`. So, if we were to use `mov rax, rsp`, we won't be moving the value `0x1` to `rax`, but we will be moving the pointer address `0x00007fffffffe490` to `rax`.


- To move the actual value we have to use square brackets `[]`, which in `x86_64` assembly and `Intel` syntax means `load value at address`. So, in the same above example, if we wanted to move the final value `rsp` is pointing to, we can wrap `rsp` in square backets, like `mov rax, [rsp]`. This `mov` instuction will move the final value rather than the immediate value

```nasm
global  _start

section .text
_start:
    mov rax, rsp
    mov rax, [rsp]
```
### Loading Value Pointers
`lea`: Load effective address.
```nasm
lea rax, [rsp]
```
when using `[]`, we may need to set the data size before the square brackets, like `byte` or `qword`. In most cases `nasm` will automatically do that for us. We can see above that the final instruction is actually `mov raw, QWORD PTR[rsp]`. `nasm` also added `PTR` to specify mvoing a value from a pointer
`write` syscall

#lea #loadeffectiveaddress
How `lea` works and how it differs from `mov`
```nasm
global _start

section .text:
	lea rax, [rsp+10]
	mov rax, [rsp+10]
```



Who provides documents that are helpful with improving or implementing a sound security strategy for organizations?

This type of question contains radio buttons and checkboxes for selection of options. Use Tab for navigation and Enter or space to select the option.


NIST and this is correct answer



Intellectual **CAPITAL**



Which of the following is not recommended as a mitigation strategy?


**High turnover rates** 



Not a rec. mitigation strat
**High Turnover rates**



Which mitigation effort ensures all systems are up to date?
**Hardening**




Who appoints incident response team members?
**Management**




Which of the following are not In the CIRT
**IT Users**


incident must be contained
**Contained**





what is one of th emost important investments in ensuring an organization's survivability in the event of a disaster?
**Business continuity**


0AfZs_tools_gotit

which of the following is not necessary in handling security plans?
**Default to latent policy**




Which systems post the biggest risks to an organization's infrastructure?
**Legacy**







Responsible for DBMS?
**DBA**



A __ Plan is developed to keep the DBMS in a healthy state
**tuning**


Threats to data __ occur when
**Availability
**





























































































