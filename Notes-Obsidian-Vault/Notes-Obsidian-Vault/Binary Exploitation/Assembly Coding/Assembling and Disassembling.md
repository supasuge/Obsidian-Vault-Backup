## Table of Contents

  - [Table of Contents](#Table\of\Contents)
- [Assembling](#assembling)
    - [Assembling the code](#Assembling\the\code)
  - [Linking](#Linking)
        - [Bash Scripting For Time Convenience](#Bash\Scripting\For\Time\Convenience)
    - [Dissassembling](#Dissassembling)

## Table of Contents

- [Assembling](#assembling)
    - [Assembling the code](#Assembling\the\code)
  - [Linking](#Linking)
        - [Bash Scripting For Time Convenience](#Bash\Scripting\For\Time\Convenience)
    - [Dissassembling](#Dissassembling)

# Assembling

Assembly files usually use the `.s` or `.asm` or `.nsam` extensions. we will be using the `.s`

```nasm
global _start

section .data
    message db "Hello HTB Academy!"
    length equ $-message

section .text
_start:
    mov rax, 1
    mov rdi, 1
    mov rsi, message
    mov rdx, length
    syscall

    mov rax, 60
    mov rdi, 0
    syscall
```
`[Title: helloWorld.s]`

Note how we used `equ` to dynamically calculate the length of `message`, instead of using a static integer.
### Assembling the code 
```bash
nasm -f elf64 helloWorld.s
```
	Note: `-f elf64` is used to note we want to assemble a 64-bit assembly code. If we want to assemble 32-bit code, just use `-f elf`

- The output should be a `helloWorld.o` object file, which is then assembled into machine code. along with the details of all variables and sections.
## Linking
	Final Step!
Now we must `ld` or link the `helloWorld.o` object file, though assembled, it still cannot be executed. This is because many references and labels by `nasm` need to be resolved into actual addressesm, along with linkning the file with various OS libraries.

This is why a Linux binary is called `ELF`, which stands for an `Executable and Linkable Format`. To link a file using `ld`, we can use the following command:

```bash
ld -o helloWorld helloWorld.o
```
*Note: if we were to assemble a 32-bit binary, we need to add the `-m elf_i386` flag*
Once we link the file with ld, should have the final executable.
##### Bash Scripting For Time Convenience
```bash
#!/bin/bash

fileName="${1%%.*}" # remove .s extension

nasm -f elf64 ${fileName}".s"
ld ${fileName}".o" -o ${fileName}
[ "$2" == "-g" ] && gdb -q ${fileName} || ./${fileName}"
```
**Usage**:
- `chmod +x {script_name}.sh`
- `bash assembler.sh [Assembly_file_to_be_assembled_from]`

![[Pasted image 20231203180708.png]]

![[Pasted image 20231203180818.png]]

### Dissassembling
- `objdump` - Tool which dumps machine code from a file and interprets the assembly instruction of each hex code
- To disassemble a binary use the `-D` flag
	- we will also use the flag `-M intel`, so that `objdump` would write the instructions in the **Intel syntax**, which we are using.

We see that our original assembly code is highly preserved, with the only change being `0x402000` used in place of the `message` variable and replacing the `length` constant with its value of `0x12`. We also see that `nasm` efficiently changed our `64-bit` registers to the `32-bit` sub-registers where possible, to use less memory when possible, like changing `mov rax, 1` to `mov eax,0x1`.

If we wanted to only show the assembly code, without machine code or addresses, we could add the `--no-show-raw-insn --no-addresses` flags, as follows:

Let's start by disassembling our final `ELF` executable file:

```shell
objdump -M intel -d helloWorld

helloWorld:     file format elf64-x86-64

Disassembly of section .text:

0000000000401000 <_start>:
  401000:	b8 01 00 00 00       	mov    eax,0x1
  401005:	bf 01 00 00 00       	mov    edi,0x1
  40100a:	48 be 00 20 40 00 00 	movabs rsi,0x402000
  401011:	00 00 00
  401014:	ba 12 00 00 00       	mov    edx,0x12
  401019:	0f 05                	syscall
  40101b:	b8 3c 00 00 00       	mov    eax,0x3c
  401020:	bf 00 00 00 00       	mov    edi,0x0
  401025:	0f 05                	syscall
```
Above we can see the original assembly code is highly preserved, with only change being `0x402000` used in place of `message` variable and replacing the `length` constant with its value of `0x12`. We also see that `nasm` efficiently changed our `64-bit` registers to the `32-bit` sub-registers where possible, to use less memory when possible, like changing `mov rax, 1` to `mov eax,0x1`.

- If we wanted to only show the **assembly code**, without machine code or addresses, we could add the `--no-show-raw-insn --no-addresses` flags, as follows:

```bash
objdump -M intel --no-show-raw-insn --no-addresses -d helloWorld
helloWorld:     file format elf64-x86-64

Disassembly of section .text:

<_start>:
        mov    eax,0x1
        mov    edi,0x1
        movabs rsi,0x402000
        mov    edx,0x12
        syscall 
        mov    eax,0x3c
        mov    edi,0x0
        syscall
```

Note that `objdump` changed the third instruction into `movabs`. This is the same as `mov`. In case you need to reassemble  the code, you can change it back to `mov`.

The `-d` flag will only dissasssemble the `.text` section of our code. To dump any strings, we can use the `-s` flag. and add `-j .data` to only examine the `.data` section. This means that we also do not need to add `-M intel` the final command is as follows:
```bash
objdump -sj .data helloWorld
```


```shell-session
gdxqpardo@htb[/htb]$ ./assembler.sh helloWorld.s -g
```


```shell
$ objdump -M intel -d helloWorld
helloWorld:     file format elf64-x86-64

Disassembly of section .text:

0000000000401000 <_start>:
  401000:	b8 01 00 00 00       	mov    eax,0x1
  401005:	bf 01 00 00 00       	mov    edi,0x1
  40100a:	48 be 00 20 40 00 00 	movabs rsi,0x402000
  401011:	00 00 00
  401014:	ba 12 00 00 00       	mov    edx,0x12
  401019:	0f 05                	syscall
  40101b:	b8 3c 00 00 00       	mov    eax,0x3c
  401020:	bf 00 00 00 00       	mov    edi,0x0
  401025:	0f 05                	syscall
```
![[Pasted image 20231203191254.png]]