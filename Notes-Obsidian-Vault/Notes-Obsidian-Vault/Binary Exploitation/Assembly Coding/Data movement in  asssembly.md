## Table of Contents

  - [Table of Contents](#Table\of\Contents)
    - [Moving Data](#Moving\Data)
    - [Loading Data](#Loading\Data)
  - [Address Pointers](#Address\Pointers)

## Table of Contents

    - [Moving Data](#Moving\Data)
    - [Loading Data](#Loading\Data)
  - [Address Pointers](#Address\Pointers)

- Used to move data between addresses, moving data between registers and memory addresses. and loading immediate data into registers or memory addresses. 

| Instruction | Description | Example |
| :--: | :--: | :--: | 
| `mov` |  Move data or load immediate data    |   `mov rax, 1` -> `rax = 1`    |
| `lea` | Load an address pointing to a value | `lea rax. [rsp+5]` -> `rax = rsp+5` |
| `xchg` | Swap data between two registers or addressess | `xchg raw, rbx -> rax = rbx, rbx = rax` |

### Moving Data
`mov` the instruction as the very first instructions in the module project `fibonacci`. Load the initial values (`f0=0 and f^1=1)` to `rax = 0` and `rbx = 1`. Call this file `fib.s`.
```nasm
global _start

section .text
_start:
	mov rax, 0
	mov rbx, 1
```

In assembly, moving data does not affect the source operand. So, we can consider `mov` as a `copy` function, rather than an actual move.


### Loading Data
Can load immediate data using the `mov` instruction. Ex: can load the value of the `rax` register using the `mov raxx, 1` instruction. The size of the loaded data depends on the size of the destination register. For example, in the above `mov rax, 1` instruction, since we used the 64-bit registers `rax`, it will be moving a 64-bit representation of the number `1` (i.e., `0x00000001`) which is not efficient.

It's more efficient to use a register size that matches out data size. For example, we will get the same result as the above example if we use `mov al, 1` since we are moving 1-byte register (`al`) which is much more efficient. This is evident when we look at the disassembly of both instructions in `objdump`.



The `xchg` instruction will swap the data between the two registers. Try adding `xchg rax, rbx` to the end of the code, assemble it, and then run it through `gdb` to see how it works.



The `xchg` instruction will swap the data between the two registers.




## Address Pointers

Another critical concept to understand is using pointers. In many cases, we would see that the register or address we are using does not immediately contain the final value but contains another address that points to the final value.
**Pointer Registers**: `rsp`, `rbp`, `rip`


