## Table of Contents

  - [Table of Contents](#Table\of\Contents)
- [Table of contents](#table\of\contents)
  - [Installation](#Installation)
  - [Getting Started](#Getting\Started)
    - [Commands](#Commands)
      - [Info](#Info)
      - [Functions](#Functions)
      - [Variables](#Variables)
      - [Disassemble](#Disassemble)
- [Debugging with GDB](#debugging\with\gdb)
  - [Break](#Break)
    - [Examine](#Examine)
      - [Instructions](#Instructions)
      - [Strings](#Strings)
      - [Addresses](#Addresses)
      - [Step Instruction](#Step\Instruction)
      - [Step count](#Step\count)
      - [Step](#Step)
  - [Modify](#Modify)
    - [Addresses](#Addresses)
      - [Objdump](#Objdump)

## Table of Contents

- [Table of contents](#table\of\contents)
  - [Installation](#Installation)
  - [Getting Started](#Getting\Started)
    - [Commands](#Commands)
      - [Info](#Info)
      - [Functions](#Functions)
      - [Variables](#Variables)
      - [Disassemble](#Disassemble)
- [Debugging with GDB](#debugging\with\gdb)
  - [Break](#Break)
    - [Examine](#Examine)
      - [Instructions](#Instructions)
      - [Strings](#Strings)
      - [Addresses](#Addresses)
      - [Step Instruction](#Step\Instruction)
      - [Step count](#Step\count)
      - [Step](#Step)
  - [Modify](#Modify)
    - [Addresses](#Addresses)
      - [Objdump](#Objdump)

# Table of contents
- [Installation](#Installation)
- [Getting Started](#Getting\Started)
- [Commands](#Commands)
	- [Info](#Info)
	- [Functions](#Functions)
	- [Variables](#Variables)
	- [Disassemble](#Disassemble)
- [Debugging With GDB](#Debugging\With\GDB)
	- [Breakpoints](#Break)
	- [Examine](#Examine)
		- [Instructions](#Instructions)
		- [Strings](#Strings)
		- [Addresses](#Addresses)
		- [Step Instruction](#Step\Instruction)
		- [Step Count](#Step\Count)
		- [Step](#Step)
	- 
## Installation
```bash
sudo apt-get update && sudo apt-get install gdb
```

One of the great features of `GDB` is it's support for third-party plugins. An excellent plugin that is well maintained and has good documentation is `GEF`. [GEF](https://github.com/hugsy/gef) is a free and oppen source GDB plugin that is built specifically for reverse engineering and binary exploitation. 

```shell-session
gdxqpardo@htb[/htb]$ wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py
gdxqpardo@htb[/htb]$ echo source ~/.gdbinit-gef.py >> ~/.gdbinit
```
- [Documentation](https://hugsy.github.io/gef/)
## Getting Started
```bash
gdb -q ./helloWorld
```

Going forward, we will frequently be assembling and linking our assembly code and then running it with `gdb`. To do so quickly, we can use the `assembler.sh` script we wrote in the previous section with the `-g` flag. It will assemble and link the code, and then run it with `gdb`, as follows:

GNU Debugger (GDB)

```bash
gdxqpardo@htb[/htb]$ ./assembler.sh helloWorld.s -g
```

### Commands

#### Info

Once `gdb` is started, we can use `info` command to view general information about the program, like its functions or variables.
- Tip: If we want to understand how any command runs within GDB, we can use the help CMD command to get its documentation. Ex: `help info`

#### Functions

To start use the `info` command to check which `functions` are defined within the binary:
```bash
info functions
```

#### Variables

We can also use the `info variables` command to view all available variables within the program:

```bash
info variables

All defined variables:

Non-debugging symbols:
0x0000000000402000  message
0x0000000000402012  __bss_start
0x0000000000402012  _edata
0x0000000000402018  _end
```

#### Disassemble
To view the instructions within a specific function, we can use the `disassemble` or `disas` command along with the function name, as follows:

```bash
disas _start


Dump of assembler code for function _start:
   0x0000000000401000 <+0>:	mov    eax,0x1
   0x0000000000401005 <+5>:	mov    edi,0x1
   0x000000000040100a <+10>:	movabs rsi,0x402000
   0x0000000000401014 <+20>:	mov    edx,0x12
   0x0000000000401019 <+25>:	syscall
   0x000000000040101b <+27>:	mov    eax,0x3c
   0x0000000000401020 <+32>:	mov    edi,0x0
   0x0000000000401025 <+37>:	syscall
End of assembler dump.
```

As we can see, the output we got closely resembles our assembly code and the disassembly output we got from `objdump` in the previous section. We need to focus on the main thing from this disassembly: the memory addresses for each instruction and operands (i.e., arguments).

`Having the memory address is critical for examining the variables/operands and setting breakpoints for a certain instruction.`

You may notice through debugging that some memory addresses are in the form of `0x00000000004xxxxx`, rather than their raw address in memory `0xffffffffaa8a25ff`. This is due to `$rip-relative addressing` in Position-Independent Executables `PIE`, in which the memory addresses are used relative to their distance from the instruction pointer `$rip` within the program's own Virtual RAM, rather than using raw memory addresses. This feature may be disabled to reduce the risk of binary exploitation.




# Debugging with GDB

|Step|Description|
|---|---|
|`Break`|Setting breakpoints at various points of interest|
|`Examine`|Running the program and examining the state of the program at these points|
|`Step`|Moving through the program to examine how it acts with each instruction and with user input|
|`Modify`|Modify values in specific registers or addresses at specific breakpoints, to study how it would affect the execution|

## Break
The first step in debugging is setting breakpoints to stop the execution at a specific location or when a particular condition is met. This helps us in examining the state of the program and the value of registers at that point. `Breakpoints` also allow us to stop the program's execution at that point so that we can step into each instruction and examine how it changes the program and values

We can set a breakpoint at a specific address or for a particular function. To set a breakpoint, we can use the `break` or `b` command along with the address or function name we want to break at. For example, to follow all instructions run by our program, let's break at the `_start` function, as follows:

```shell
gef➤  b _start

Breakpoint 1 at 0x401000
```

Now, in order to start our program, we can use the `run` or `r` command:

```bash
gef➤  b _start
Breakpoint 1 at 0x401000
gef➤  r
Starting program: ./helloWorld 
Breakpoint 1, 0x0000000000401000 in _start ()
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x0               
$rbx   : 0x0               
$rcx   : 0x0               
$rdx   : 0x0               
$rsp   : 0x00007fffffffe310  →  0x0000000000000001
$rbp   : 0x0               
$rsi   : 0x0               
$rdi   : 0x0               
$rip   : 0x0000000000401000  →  <_start+0> mov eax, 0x1
...SNIP...
───────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe310│+0x0000: 0x0000000000000001	 ← $rsp
0x00007fffffffe318│+0x0008: 0x00007fffffffe5a0  →  "./helloWorld"
...SNIP...
─────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400ffa                  add    BYTE PTR [rax], al
     0x400ffc                  add    BYTE PTR [rax], al
     0x400ffe                  add    BYTE PTR [rax], al
 →   0x401000 <_start+0>       mov    eax, 0x1
     0x401005 <_start+5>       mov    edi, 0x1
     0x40100a <_start+10>      movabs rsi, 0x402000
     0x401014 <_start+20>      mov    edx, 0x12
     0x401019 <_start+25>      syscall 
     0x40101b <_start+27>      mov    eax, 0x3c
─────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "helloWorld", stopped 0x401000 in _start (), reason: BREAKPOINT
───────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x401000 → _start()
```

If we want to set a breakpoint at a certain address, like `_start+10`, we can either `b *_start+10` or `b *0x40100a`:

```shell-session
gef➤  b *0x40100a
Breakpoint 1 at 0x40100a
```
- The `*` tells `GDB` to break at the instruction stored in `0x40100a`

If we want to see what breakpoints we have at any point of the execution, we can use the `info breakpoint` command. We can also `disable`, `enable`, or `delete` any breakpoint. Furthermore, GDB also supports setting conditional breaks that stop the execution when a specific condition is met.

### Examine
Next step in debugging is `examining` the values in registers and addresses. As we can see in the previous terminal output, `gef` automatically gave us a lot of helpful information when we hit our breakpoint. This is one of the benefits of having the `gef` plugin. It automates many steps that we usually take at every breakpoint, like examining the registers, the stack, and the current assembly instructions.


To manually examine any of the addresses or registers or examine any other, we can use the `x` command in the format of `x/FMT ADDRESS`, as `help x` would tell us. The `ADDRESS` is the address or register we want to examine, while `FMT` is the examine format. The examine format `FMT` can have three parts:

|Argument|Description|Example|
|---|---|---|
|`Count`|The number of times we want to repeat the examine|`2`, `3`, `10`|
|`Format`|The format we want the result to be represented in|`x(hex)`, `s(string)`, `i(instruction)`|
|`Size`|The size of memory we want to examine|`b(byte)`, `h(halfword)`, `w(word)`, `g(giant, 8 bytes)`|

#### Instructions
If we wanted to examine the next four instructions in line, we will have to examine the `$rip` register. (which holds the address of the next instruction), and use `4` for the `count`, `i` for the `format`, and `g` for the `size` (8-bytes or 64-bits). So the final examine command would be `x/4ug $rip`

```shell-session
GEF> x/4ig $rip

=> 0x401000 <_start>:	mov    eax,0x1
   0x401005 <_start+5>:	mov    edi,0x1
   0x40100a <_start+10>:	movabs rsi,0x402000
   0x401014 <_start+20>:	mov    edx,0x12
```


#### Strings

We can also examine a variable stored at a specific memory address. We know that our `message` variable is stored at the `.data` section on address `0x402000` from our previous disassembly. We also see the upcoming command `movabs rsi, 0x402000`, so we may want to examine what is being moved from `0x402000`.

```shell
gef➤  x/s 0x402000

0x402000:	"Hello HTB Academy!"
```

Note: if we don't specify the `Size` or `Format`, it will default to the last one we used.

#### Addresses

The most common format of examining is hex `x`. We often need to examine addresses and registers containing hex data, such as memory addresses, instructions, or binary data. Let us examine the same previous instruction, but in `hex` format, to see how it looks:

```shell
gef➤  x/wx 0x401000
0x401000 <_start>:	0x000001b8
```

We see instead of `mov eax,0x1`, we get `0x000001b8`, which is the hex representation of the `mov eax,0x1` machine code in little-endian formatting.

- This is read as: `b8 01 00 00`.

Try repeating the commands we used for examining strings using `x` to examine them in hex. We should see the same text but in hex format. We can also use `GEF` features to examine certain addresses. For example, at any point we can use the `registers` command to print out the current value of all registers:



```bash
gef➤  registers
$rax   : 0x0               
$rbx   : 0x0               
$rcx   : 0x0               
$rdx   : 0x0               
$rsp   : 0x00007fffffffe310  →  0x0000000000000001
$rbp   : 0x0               
$rsi   : 0x0               
$rdi   : 0x0               
$rip   : 0x0000000000401000  →  <_start+0> mov eax, 0x1
...SNIP...
```


#### Step Instruction

The `stepi` or `si` command will step through the assembly instructions one by one, which is the smallest level of steps possible while debugging. Let us use the `si` command to see how we get to the next instruction:

```bash
gef➤  si
0x0000000000401005 in _start ()
   0x400fff                  add    BYTE PTR [rax+0x1], bh
 →   0x401005 <_start+5>       mov    edi, 0x1
     0x40100a <_start+10>      movabs rsi, 0x402000
     0x401014 <_start+20>      mov    edx, 0x12
     0x401019 <_start+25>      syscall 
─────────────────────────────────────────────────────────────────────────────────────── threads ────
     [#0] Id 1, Name: "helloWorld", stopped 0x401005 in _start (), reason: SINGLE STEP
```

As we can see, we took exactly one step and stopped again at the `mov edi, 0x1` instruction.

#### Step count
Similarly to examine, we can repeat the `si` command by adding a number after it. For example, if we wanted to move 3 steps to reach the `syscall` instruction, we can do so as follows:

```bash
gef➤  si 3
0x0000000000401019 in _start ()
─────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x401004 <_start+4>       add    BYTE PTR [rdi+0x1], bh
     0x40100a <_start+10>      movabs rsi, 0x402000
     0x401014 <_start+20>      mov    edx, 0x12
 →   0x401019 <_start+25>      syscall 
     0x40101b <_start+27>      mov    eax, 0x3c
     0x401020 <_start+32>      mov    edi, 0x0
     0x401025 <_start+37>      syscall 
─────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "helloWorld", stopped 0x401019 in _start (), reason: SINGLE STEP
```


#### Step
The `step` or `s` command, on the other hand, will continue until the following line of code is reached or until it exits from the current function. If we run an assembly code, it will break when we exit the current function `_start`.

If there's a call to another function within this function, it'll break at the beginning of that function. Otherwise, it'll break after we exit this function after the program's end. Let us try using `s`, and see what happens:

Debugging with GDB

```shell-session
gef➤  step

Single stepping until exit from function _start,
which has no line number information.
Hello HTB Academy!
[Inferior 1 (process 14732) exited normally]
```

We see that the execution continued until we reached the exit from the `_start` function, so we reached the end of the program and `exited normally` without any errors. We also see that `GDB` printed the program's output `Hello HTB Academy!` as well.

## Modify
The final step in debugging is `modifying` values in registers and addresses at a certain point of execution. This helps us in seeing how this would affect the execution of the program.

### Addresses
To modify values in GDB, we can use the `set` command. However, we will utilize the `patch` command in `GEF` to make this step much easier. Let's enter `help patch` in GDB to get its help menu:
```bash
gef> help patch
Write specified values to the specified address.
Syntax: patch (qword|dword|word|byte) LOCATION VALUES
patch string LOCATION "double-escaped string"
...SNIP...
```

As we can see, we have to provide the `type/size` of the new value, the `location` to be stored, and the `value` we want to use. Try changing the `.data` section (At address `0x402000` as we saw earlier) to the string `Patched!\n`. 

We will break at the first `syscall` at `0x401019` and then do the patch as follow:
```shell-session
gef➤  break *0x401019

Breakpoint 1 at 0x401019
gef➤  r
gef➤  patch string 0x402000 "Patched!\\x0a"
gef➤  c

Continuing.
Patched!
 Academy!
```

#### Objdump
	Example: ELF Executable

```bash
objdump -M intel -d <prog_name>
```

- Only changes are `0x402000` format hex used in place of the `message` variable and replacing the `length` constant with `0x12`. `nasm` changed the registers (64 -> 32)
	- This is to use less memory when possible.
- To show the raw assembly code, without machine code or addressess:
```bash
objdump --no-show-raw-insn --no-addresses -d <........>
```
- `-d`: onyt disassemble the `.text` section of our code. 
- `-s`: dump any string
- `-j`: dump `.data`


