## Table of Contents

    - [Function Call Flow](#Function\Call\Flow)
- [Windows Memory](#windows\memory)
    - [Page State](#Page\State)
    - [Page Protection Options](#Page\Protection\Options)
    - [Memory Protection](#Memory\Protection)
    - [Writing To Memory Example](#Writing\To\Memory\Example)

1. **User Processes** - A program/application executed by the user such as Notepad, Google Chrome or Microsoft Word.
    
2. **Subsystem DLLs** - DLLs that contain API functions that are called by user processes. An example of this would be `kernel32.dll` exporting the [CreateFile](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea) Windows API (WinAPI) function, other common subsystem DLLs are `ntdll.dll`, `advapi32.dll`, and `user32.dll`.
    
3. **Ntdll.dll** - A system-wide DLL which is the lowest layer available in user mode. This is a special DLL that creates the transition from user mode to kernel mode. This is often referred to as the Native API or NTAPI.
    
4. **Executive Kernel** - This is what is known as the Windows Kernel and it calls other drivers and modules available within kernel mode to complete tasks. The Windows kernel is partially stored in a file called `ntoskrnl.exe` under "C:\Windows\System32".

### Function Call Flow

The image below shows an example of an application that creates a file. It begins with the user application calling the `CreateFile` WinAPI function which is available in `kernel32.dll`. `Kernel32.dll` is a critical DLL that exposes applications to the WinAPI and is therefore can be seen loaded by most applications. Next, `CreateFile` calls its equivalent NTAPI function, `NtCreateFile`, which is provided through `ntdll.dll`. `Ntdll.dll` then executes an assembly `sysenter` (x86) or `syscall` (x64) instruction, which transfers execution to kernel mode. The kernel `NtCreateFile` function is then used which calls kernel drivers and modules to perform the requested task.

![image](https://maldevacademy.s3.amazonaws.com/images/Basic/windows-arch-flow.png)


# Windows Memory

![Virtual-Mem](https://maldevacademy.s3.amazonaws.com/images/Basic/5-windows-memory-management/virtual-memory.png)

### Page State

The pages residing within a process's virtual address space can be in one of 3 states:

1. **Free** - The page is neither committed nor reserved. The page is not accessible to the process. It is available to be reserved, committed, or simultaneously reserved and committed. Attempting to read from or write to a free page can result in an access violation exception.
    
2. **Reserved** - The page has been reserved for future use. The range of addresses cannot be used by other allocation functions. The page is not accessible and has no physical storage associated with it. It is available to be committed.
    
3. **Committed** - Memory charges have been allocated from the overall size of RAM and paging files on disk. The page is accessible and access is controlled by one of the memory protection constants. The system initializes and loads each committed page into physical memory only during the first attempt to read or write to that page. When the process terminates, the system releases the storage for committed pages.
    

### Page Protection Options

Once the pages are committed, they need to have their protection option set. The list of memory protection constants can be found [here](https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants) but some examples are listed below.

- `PAGE_NOACCESS` - Disables all access to the committed region of pages. An attempt to read from, write to or execute the committed region will result in an access violation.
    
- `PAGE_EXECUTE_READWRITE` - Enables Read, Write and Execute. This is highly discouraged from being used and is generally an IoC because it's uncommon for memory to be both writable and executable at the same time.
    
- `PAGE_READONLY` - Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation.

### Memory Protection

Modern operating systems generally have built-in memory protections to thwart exploits and attacks. These are also important to keep in mind as they will likely be encountered when building or debugging the malware.

- **Data Execution Prevention (DEP)** - DEP is a system-level memory protection feature that is built into the operating system starting with Windows XP and Windows Server 2003. If the page protection option is set to PAGE_READONLY, then DEP will prevent code from executing in that memory region.
    
- **Address space layout randomization (ASLR)** - ASLR is a memory protection technique used to prevent the exploitation of memory corruption vulnerabilities. ASLR randomly arranges the address space positions of key data areas of a process, including the base of the executable and the positions of the stack, heap and libraries.

When working with Windows processes, it's important to note whether the process is x86 or x64. x86 processes have a smaller memory space of 4GB (`0xFFFFFFFF`) whereas x64 has a vastly larger memory space of 128TB (`0xFFFFFFFFFFFFFFFF`)

This example goes through small code snippets to better understand how one can interact with Windows memory via C functions and Windows APIs. The first step in interacting with memory is allocating memory. The snippet below demonstrates several ways to allocate memory which is essentially reserving a memory inside the running process.
```c
//Method 1 - using malloc()
PVOID pAddress = malloc(100);
//Method 2 - HeapAlloc()
Pvoid pAddress = HeapAlloc(GetProcessHeap(), 0, 100);
//Method3 - using LocalAlloc()
PVOID pAddress = LocalAlloc(LPTR, 100);
```

### Writing To Memory Example

The next step after memory allocation is generally writing to that buffer. Several options can be used to write to memory but for this example, `memcpy` is used.

```c
PVOID pAddress	= HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 100);

CHAR* cString	= "MalDev Academy Is The Best";

memcpy(pAddress, cString, strlen(cString));
```
Depending on what function was used to allocate memory, it will have a corresponding memory deallocation function. For example:

- Allocating with `malloc` requires the use of the `free` function.
    
- Allocating with `HeapAlloc` requires the use of the `HeapFree` function.
    
- Allocating with `LocalAlloc` requires the use of the `LocalFree` function.
    

The images below show `HeapFree` in action, freeing allocated memory at address `0000023ADE449900`. Notice the address `0000023ADE449900` still exists within the process but its original content was overwritten with random data. This new data is most likely due to a new allocation performed by the OS inside the process.

