## Table of Contents

  - [Intro to File Inclusions](#Intro\to\File\Inclusions)
    - [Local File Inclusion (LFI)](#Local\File\Inclusion\(LFI))
    - [Vulnerable Code Examples](#Vulnerable\Code\Examples)
      - [PHP](#PHP)
      - [NodeJS](#NodeJS)
      - [Java](#Java)
      - [.NET](#.NET)
    - [Key Differences in File Inclusion](#Key\Differences\in\File\Inclusion)
  - [Path Traversal](#Path\Traversal)
    - [Absolute Path Inclusion](#Absolute\Path\Inclusion)
    - [Appending/Prepending Strings to Paths](#Appending/Prepending\Strings\to\Paths)
      - [Bypass via Directory Traversal](#Bypass\via\Directory\Traversal)
    - [Filename Prefix](#Filename\Prefix)
      - [Bypass via `/` Prefix](#Bypass\via\`/`\Prefix)
    - [Appended Extensions](#Appended\Extensions)

Certainly! Here's a comprehensive summary of the provided text in Markdown format, complete with examples and enhanced details.

---

## Intro to File Inclusions

Dynamic web pages often utilize HTTP parameters to decide the content displayed. When not securely implemented, attackers can manipulate these parameters, causing **Local File Inclusion (LFI)** vulnerabilities.

### Local File Inclusion (LFI)

LFI is typically seen in templating engines. Templating engines allow consistent aesthetics across a web application by loading static content and adding dynamic data based on parameters. For example, `/index.php?page=about` might load `about.php` as its dynamic content. If the parameter can be controlled by an attacker, they can force the application to load unintended files.

**Dangers**:
- Source code disclosure
- Exposure of sensitive data
- Possible remote code execution

### Vulnerable Code Examples

#### PHP

PHP might use the `include()` function to load files based on user input:

```php
if (isset($_GET['language'])) {
    include($_GET['language']);
}
```

Here, an unchecked `language` parameter can lead to LFI.

#### NodeJS

NodeJS may use parameters to decide file content:

```javascript
if(req.query.language) {
    fs.readFile(path.join(__dirname, req.query.language), function (err, data) {
        res.write(data);
    });
}
```

In this scenario, the `language` parameter can be manipulated to force the application to read any file.

#### Java

Java-based applications might use the following:

```jsp
<c:if test="${not empty param.language}">
    <jsp:include file="<%= request.getParameter('language') %>" />
</c:if>
```

Here, the `language` parameter dictates which file is loaded, which can be exploited.

#### .NET

.NET applications may use the `Response.WriteFile` function or similar:

```csharp
@if (!string.IsNullOrEmpty(HttpContext.Request.Query['language'])) {
    <% Response.WriteFile("<% HttpContext.Request.Query['language'] %>"); %> 
}
```

### Key Differences in File Inclusion

Some functions merely read file content, while others can execute them. Knowing these distinctions is critical:

| Function | Read Content | Execute | Remote URL |
|----------|:------------:|:-------:|:----------:|
| **PHP** | | | |
| include()/include_once() | ✅ | ✅ | ✅ |
| require()/require_once() | ✅ | ✅ | ❌ |
| file_get_contents() | ✅ | ❌ | ✅ |
| fopen()/file() | ✅ | ❌ | ❌ |
| **NodeJS** | | | |
| fs.readFile() | ✅ | ❌ | ❌ |
| res.render() | ✅ | ✅ | ❌ |
| **Java** | | | |
| include | ✅ | ❌ | ❌ |
| import | ✅ | ✅ | ✅ |
| **.NET** | | | |
| @Html.Partial() | ✅ | ❌ | ❌ |
| @Html.RemotePartial() | ✅ | ❌ | ✅ |
| Response.WriteFile() | ✅ | ❌ | ❌ |

---

Even if exploitation only results in reading the source code, the outcome can still be devastating. Source code might reveal other vulnerabilities, database keys, or sensitive credentials.


Sure, here's a detailed summary of the provided content on Path Traversal in Markdown format:

---

## Path Traversal

### Absolute Path Inclusion
Directly specifying an absolute path to a file, like `/etc/passwd`, can lead to its inclusion:

```php
include($_GET['language']);
```
When passed the path `/etc/passwd`, it directly fetches the file.

### Appending/Prepending Strings to Paths
Developers might append or prepend a string to input parameters:

```php
include("./languages/" . $_GET['language']);
```
Here, directly passing `/etc/passwd` would try fetching `./languages//etc/passwd`, which doesn't exist.

> **Note**: Always disable verbose PHP errors in production. While they are useful for learning, they can be exploited by attackers.

#### Bypass via Directory Traversal
To circumvent the above, relative paths can be used:

1. Use `../` to reference the parent directory.
2. Traverse back multiple directories using `../../`, `../../../`, etc. until the root path is reached.
3. After reaching the root, specify the absolute path.

Example:
``` 
../../../../etc/passwd
```

> **Tip**: Be efficient. Determine the precise number of directories to traverse. For instance, `/var/www/html/` is three directories from root, so use `../../../`.

### Filename Prefix
Sometimes, input might be appended after a string:

```php
include("lang_" . $_GET['language']);
```
With this, if you attempt path traversal, `lang_../../../etc/passwd` would be invalid. 

#### Bypass via `/` Prefix
By prefixing with `/`, the application considers the prefix as a directory:

``` 
/lang_../../../etc/passwd
```

### Appended Extensions

On occasions, an extension might be appended:

```php
include($_GET['language'] . ".php");
```
Attempting to fetch `/etc/passwd` would try to include `/etc/passwd.php`.

---

To exploit such configurations, understanding the exact path and filename manipulations is crucial. Techniques such as directory traversal or introducing valid filename elements (like a `/` prefix) can help bypass these protections.



