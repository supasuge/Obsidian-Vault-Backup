## Table of Contents

    - [Understanding Mass Assignment Vulnerability](#Understanding\Mass\Assignment\Vulnerability)
    - [Examples](#Examples)
      - [Vulnerable Code](#Vulnerable\Code)
      - [Exploit Code](#Exploit\Code)
    - [How to Prevent](#How\to\Prevent)
      - [Secure Code](#Secure\Code)

### Understanding Mass Assignment Vulnerability

Mass assignment is a feature in many modern web frameworks that allows developers to bind client-side form parameters to server-side object attributes. This functionality is a big productivity boost because it helps to automatically populate the fields of a model object without requiring explicit, field-by-field assignment.

However, this feature can become a security risk if not handled carefully. An attacker can potentially send extra, uninvited parameters in a request to update fields that were intended to be read-only or internal to the system.

### Examples

Let's consider a simple example using a pseudo-Laravel PHP framework syntax for demonstration purposes. Imagine a `User` model with the following fields:

- `id`
- `username`
- `email`
- `isAdmin`

Normal users should be allowed to update only their `username` and `email`. The `isAdmin` field is meant to be read-only and set only by administrators.

#### Vulnerable Code

In a vulnerable Laravel code, you might see something like this:

```php
public function updateProfile(Request $request, $id) {
    $user = User::find($id);
    $user->update($request->all());
}
```

Here, `$request->all()` fetches all data sent from the client-side, and `update` function would update all corresponding fields in the database. Now imagine that a malicious user sends a request with an additional `isAdmin` field:

```http
POST /updateProfile
{
    "username": "newUsername",
    "email": "newEmail@example.com",
    "isAdmin": 1
}
```

The above code will blindly update the `isAdmin` field, thus elevating the user to admin status.

#### Exploit Code

An attacker can use a tool like `curl` to send the malicious payload:

```bash
curl -X POST http://example.com/updateProfile \
     -d 'username=newUsername&email=newEmail@example.com&isAdmin=1'
```

### How to Prevent

You should specify exactly which fields are allowed to be updated. Laravel provides a way to protect against mass assignment vulnerabilities using the `$fillable` or `$guarded` attributes in the model.

#### Secure Code

```php
class User extends Model {
    protected $fillable = ['username', 'email'];
}
```

Or in the update method:

```php
public function updateProfile(Request $request, $id) {
    $user = User::find($id);
    $user->update($request->only(['username', 'email']));
}
```

By specifying which attributes can be mass-assigned, you limit the client's ability to change sensitive model data.

By being mindful of what attributes are open for mass assignment, developers can protect their application against unauthorized data modification. Always whitelist the parameters that you expect and require for mass assignment and disallow anything else.




**data tampering and privilege escalation** from a regular user to an administrator.

![Image for Vulnerable Scenario](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/31d541b9eb6d7f67dec8fdb60d07f8af.png)
- What is the problem here? Bob is not doing any filtering on the server side. Since using the **mass assignment feature**, he is also inserting credit values in the database (malicious actors can update that value).  
    
- The solution to the problem is pretty simple. Bob must ensure necessary filtering on the server side (`apirule6/user_s`) and ensure that the default value of credit should be inserted as `50`, even if more than 50 is received from the client side (as shown below


Security misconfiguration depicts an implementation of **incorrect and poorly configured security controls** that put the security of the whole API at stake. Several factors can result in security misconfiguration, including improper/incomplete default configuration, publically accessible cloud storage, [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS), and error messages displayed with sensitive data. Intruders can take advantage of these misconfigurations to perform detailed reconnaissance and get unauthorised access to the system. 

Security misconfigurations are usually detected by vulnerability scanners or auditing tools and thus can be curtailed at the initial level. API documentation, a list of endpoints, error logs etc., **must not be publically accessible** to ensure safety against security misconfigurations. Typically, companies deploy security controls like web application firewalls, which are not configured to block undesired requests and attacks.  

  

**Likely Impact** 

Security misconfiguration can give intruders complete knowledge of API components. Firstly, it allows intruders to bypass security mechanisms. **Stack trace or other detailed errors** can provide the malicious actor access to confidential data and essential system details, further aiding the intruder in profiling the system and gaining entry.



**How does it happen?**

Injection attacks are probably among the oldest API/web-based attacks and are still being carried out by hackers on real-world applications. Injection flaws occur when user input is **not filtered and is directly processed by an API**; thus enabling the attacker to perform unintended API actions without authorisation. An injection may come from [Structure Query Language (SQL)](https://tryhackme.com/room/sqlinjectionlm), operating system (OS) commands, Extensible Markup Language (XML) etc. Nowadays, frameworks offer functionality to protect against this attack through automatic sanitisation of data; however, applications built in custom frameworks like core PHP are still susceptible to such attacks. 

  

**Likely Impact** 

Injection flaws may lead to **information disclosure, data loss, DoS, and complete account takeover**. The successful injection attacks may also cause the intruders to access the sensitive data or even create new functionality and perform remote code execution. 

  

Practical Example  

- Continue to use the Chrome browser and Talend API Tester for debugging in the VM.  
    
- A few users of company MHT reported that their account password had changed, and they could not further log in to their original account. Consequently, the dev team found that Bob had developed a vulnerable login API endpoint `/apirule8/user/login_v` that is not filtering user input.  
    
- A malicious attacker requires the username of the target, and for the password, they can use the payload `' OR 1=1--'` and get an authorisation key for any account (as shown below).

![Image for Vulnerable Scenario](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/fb4649a8c9226d5c68d2ece9e1e1246a.png)  

- Bob immediately realised his mistake; he updated the API endpoint to `/apirule8/user/login_s` and used parameterised queries and built-in filters of Laravel to sanitise user input.
- As a result, all malicious payloads on username and password parameters were effectively mitigated (as shown below)

![Image for secure scenario](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/496f9d46040c7a3088f710bbe29cfc0a.png)  

**Mitigation Measures**

- Ensure to use a well-known library for client-side input validation.
- If a framework is not used, all client-provided data must be validated first and then filtered and sanitised. 
- Add necessary security rules to the Web Application Firewall (WAF). Most of the time, injection flaws can be mitigated at the network level.
- Make use of built-in filters in frameworks like Laravel, Code Ignitor etc., to validate and filter data.
