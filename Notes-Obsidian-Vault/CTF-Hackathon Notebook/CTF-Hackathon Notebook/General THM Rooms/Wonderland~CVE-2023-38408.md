## Table of Contents

    - [1. Making the Stack executable](#1.\Making\the\Stack\executable)
  - [2. Copy the shellcode to the stack](#2.\Copy\the\shellcode\to\the\stack)
  - [Step 1: Add Alice's public key](#Step\1:\Add\Alice's\public\key)

The discovered vulnerability impacts all OpenSSH versions preceding 9.3p2, posing substantial risks for users who utilize agent forwarding in untrusted environments. To safeguard against the threat of remote code execution, it is strongly advised to upgrade to OpenSSH version 9.3p2 or above.

```
username: redqueenrebel
password: DownTheRabbitHole!
10.10.200.44
```

Initially, ssh-agent allowed loading any shared library without filtering, leading to security concerns. In response to **CVE-2016-10009**, an allow-list (`/usr/lib*/,/usr/local/lib/` by default) was added to limit library loading. However, it is possible to abuse the side effects of the library's constructors (`dlopen`) and destructors (`dlclose`) to manipulate memory and control the program flow.

Code execution can be achieved by making the stack executable, registering a signal handler for `SIGSEGV` and manipulating its code, replacing the signal handler's code with code from another library, triggering a `SIGSEGV`, and replacing his handler's code to finally jump into the stack where the shellcode is stored.

### 1. Making the Stack executable
Leveraging dlopen() to load one of the libraries grants the ability to make the stack memory region (specifically the target process ssh-pkcs11-helper's stack) executable. This allows bypassing the usual protection against executing code on the stack. 

## 2. Copy the shellcode to the stack
Once the shellcode is generated, typically using tools like msfvenom/metasploit, it can be copied to the stack memory using the socket generated from the SSH connection. The shellcode is also combiner with a NOP sled which is a sequence of No-Operation assembly intructions. The reason why is to provide a larger target for the program execution flow to land on during the gadget execution

To verify whether the process has the desired executable flag, you can use the following commands in dbg, a Linux debugger. You can repeat the next few gdb commands once you have gained access as alice:  

First, obtain the PID of the process ssh-pkcs11-helper.

1. Attach dbg to the target process using its PID.
2. Use the command info proc mapping to examine the memory mappings of the process.
3. Look for the memory region corresponding to the stack, and check its flags, marked as rwx.
Terminal

```shell-session
alice@workstation:~$ ps -aux | grep pkcs11-helperalice
1522 0.0 0.2 7788 5520 ? S 09:22 0:00 /usr/lib/openssh/ssh-pkcs11-helper
alice@workstation:~$ sudo gdb -p 1522
[snip]
29 ../sysdeps/unix/sysv/linux/poll.c: No such file or directory. (gdb) info proc mappings process 1522 Mapped address spaces:
Start Addr End Addr Size Offset Perms objfile
[snip]
0x7ffc7a83b000 0x7ffc7a85c000 0x21000 0x0 rwxp
[stack]
0x7ffc7a9df000 0x7ffc7a9e3000 0x4000 0x0 r--p
[vvar]
0x7ffc7a9e3000 0x7ffc7a9e5000 0x2000 0x0 r-xp
[vdso]
0xffffffffff600000 0xffffffffff601000 0x1000 0x0 --xp 
[snip]
```

Using GDB, you can verify whether the stack has the shellcode loaded by inspecting its content.

regarding the command $rsp+10100, its an expression that references a specific memory location relative to the stack pointer ($rsp) in this case $rsp+10100  points to the memory location located 10100 bytes above the stack pointer.


Observe that it contains a series of NOP (No Operation) instructions followed by the start of the shellcode: `0x31 0xc0 0x48 0x31 0xc0 0xff 0x48`



3. Registering a Signal Handler:

To successfully execute arbitrary code within the exploit, a custom signal handler must be registered for the `SIGSEGV` signal. This signal, known as a Segmentation Fault, is triggered when a program attempts to access an invalid memory address. By registering the signal handler, the exploit gains the ability to define a user-defined function that will be executed whenever the `SIGSEGV` signal occurs.

4. Replacing the Signal Handler's Code:

At this stage, the exploit leverages the technique of side-loading another library to replace the current signal handler's code with an alternative code segment that will jump to the stack where the shellcode is stored.

To ensure that the code segments of this new library remain mapped in memory even after `dlclose()` is invoked, the library must be marked with the "`Nodelete`" attribute. Ordinarily, when `dlclose()` is called to close a shared library, the library's code segments are unloaded from memory, and any associated resources are released. However, by utilizing the "`Nodelete`" attribute, the attacker prevents the code segments from being unloaded, effectively preserving their existence in memory beyond the `dlclose()` operation. This ensures that the replacement code, responsible for jumping to the shellcode in the stack, remains accessible and functional throughout the exploit's execution.

5. Triggering SIGSEGV:

By employing yet another library, the attacker intentionally triggers a `SIGSEGV` signal, which prompts the kernel to execute the custom signal handler previously registered. This strategic step is a critical part of the exploit's progression.

Upon receiving the `SIGSEGV` signal, the kernel recognizes that an invalid memory access has occurred and proceeds to invoke the custom signal handler rather than terminate the program abruptly. By doing so, the attacker seizes the opportunity to manipulate the program's execution and steer it toward the injected malicious code located within the NOP sled.

6. Executing the Replacement Code:

By achieving this precise jump into the executable stack, the exploit ensures that the program's execution is directed toward the specific memory location where the shellcode resides.


To get started, you need to set up the environment where your AttackBox will act as the Attacker box. Please note that the following steps are not necessary in a real-world environment and are specific to this vulnerable machine.

## Step 1: Add Alice's public key
Clear your SSH sessions by using rm -rf /tmp/ssh* on your attackbox, then add alices public key to the authorized_keys file.
AttackBox Terminal

```shell-session
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCs4FT0kCeBfQ1co/PeApZn3NmZ68mUwEEbtP598IcBBDgpe+AauGtOVNxsptmZD26yjhTXp4RJgrreUgPJQ8ICDUvASD/2W8GOl5XpYddbrcHy+djyViQV/69VskB2Y9LCobbkYPBUjIKlObqgamM7HhcNO3Zu65AAtbu+31+N+swygYjTRB37cjQOLgI7FM9nmuhyb8uSMtttTJRD7ybXPfiHV8YxLENuJU0BGggc9i/hXKQKwhEvnliiqw/XdpK/JyT6t65DFvYYkT21bPHpBDMNzPauUgr2yagKMFNe8HFQfk/QibTcLMeV0JmCGeOcv8oJP/T4xJnnoetMvZGEPZ4hXH7E3n2wksLjuF2se61/c+SIh6Zm+gUYQESTAmmbRPeTj7RcZPRN22knpSyu76eZKBf/dmHYXQlIk1gKsouFdposOpxYRJ4Wt97uEPihW/wzzT+QPcLyYoGpbFXJmpqNaOBVJw1n0KqB98dL5Ixa32FKTCzaBPHkDmK/I2M= alice@workstation" >> /root/.ssh/authorized_keys
```

Step 2: Create the IP File

Next, create a file named `/tmp/ip.txt` on your VM instance (the vulnerable machine). Inside this file, write your AttackBox's IP address as its content.  
So, for instance, if your AttackBox's IP is 10.10.10.10 you will have to run the following:

  

Workstation Terminal

```shell-session
redqueenrebel@workstation:~# echo "10.10.10.10" > /tmp/ip.txt 
```


**Step 3: Wait for Connection**
At this point, your vulnerable machine should receive, within a minute, a connection from your AttackBox.

You can use this connection to attempt to obtain the flag by leveraging your privileges.



**Exploitation:**  
At this stage, several libraries can be side-loaded. It's important to note that these libraries will be executed from the attacker's control box, but their impact will be directed at the target workstation.  

In order to execute the shellcode within the vulnerable process (`ssh-pkcs11-helper`), it is crucial that the stack of that process is flagged as executable:





