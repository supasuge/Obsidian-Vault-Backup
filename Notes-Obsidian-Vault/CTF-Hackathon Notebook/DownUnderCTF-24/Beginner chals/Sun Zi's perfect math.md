![[Pasted image 20240705121438.png]]

To determine the exact number of soldiers Han Xin had remaining, we need to solve the following system of congruences:

$$
\begin{cases} 
x \equiv 2 \pmod{3} \\
x \equiv 4 \pmod{5} \\
x \equiv 5 \pmod{7}
\end{cases}
$$

Using the Chinese remainder theorem, we find the solution module 3 * 5 * 7 = 105

- First, solve the first two congruences:
$x = 3k+2$

- Then, substitute x into the second congruence:
$3k + 2 \equiv 4 \pmod{5}$

- Subtract 2:
$3k \equiv 2 \pmod{5}$

- Then, find the multiplative inverse of 3 modulo 5, which is 2, and solve for k:
$k \equiv 2 \times 2 = 4 \pmod{5}$

So:
$k = 5m + 4$

- Substitute k back into x:
$x = 3(5m + 4) + 2 = 15m + 14$

- Next, we use this expression in the third congruence:
$15m + 14 \equiv 5 \pmod{7}$

- Subtract 14:
$15m \equiv -9 \pmod{7}$

- Simplify -9 modulo 7
$-9 \equiv -2 \pmod{7}$

Since $15 \equiv 1 \pmod{7}$:
$m \equiv -2 \pmod{7} \implies m \equiv 5 \pmod{7}$

So:
$m = 7n + 5$

Substitute $m$ back into $x$:
$x = 15(7n + 5) + 14 = 105n + 89$

Hence:
$x \equiv 89 \pmod{105}$

Since Han Xin estimated that the number of soldiers remaining is between 1000, and 1100, we find the equivalent number in this range:
$1000 \leq 89 + 105k \leq 1100$

Solving for $k$:
$911 \leq 105k \leq 1011 \\8.676 \leq k \leq 9.628$

So, $k=9$. Thus:
$x = 89 + 105 \times 9 = 89 + 945 = 1034$

Answer: $\boxed{1034}$

In python:
```python
from sympy import mod_inverse

# Given congruences:
a1, n1 = 2, 3
a2, n2 = 4, 5
a3, n3 = 5, 7

# Find the product of all moduli
N = n1 * n2 * n3

# Calculate individual components
N1 = N // n1
N2 = N // n2
N3 = N // n3

# Compute the modular inverses
inv1 = mod_inverse(N1, n1)
inv2 = mod_inverse(N2, n2)
inv3 = mod_inverse(N3, n3)

# Calculate the solution using CRT
x = (a1 * N1 * inv1 + a2 * N2 * inv2 + a3 * N3 * inv3) % N

print(f"The solution to the system of congruences is x ≡ {x} (mod {N})")

# Given the range [1000, 1100], find the appropriate value for k
k = (1000 - x + N - 1) // N  # Use floor division
solution = x + k * N

# Check if the solution is within the range
if 1000 <= solution <= 1100:
    print(f"The number of soldiers Han Xin had remaining is {solution}")
else:
    print("No solution found within the specified range")
```

Next up, the site give's us $c1, c2, c3$ as well as the corresponding $n1, n2, n3$ from the RSA equation. The goal to get the flag is to use the Chinese Remainder theorem and hadcast's broadcast attack to get the decrypted flag.

```
e = 3

c_1 = 105001824161664003599422656864176455171381720653815905925856548632486703162518989165039084097502312226864233302621924809266126953771761669365659646250634187967109683742983039295269237675751525196938138071285014551966913785883051544245059293702943821571213612968127810604163575545004589035344590577094378024637

c_2 = 31631442837619174301627703920800905351561747632091670091370206898569727230073839052473051336225502632628636256671728802750596833679629890303700500900722642779064628589492559614751281751964622696427520120657753178654351971238020964729065716984136077048928869596095134253387969208375978930557763221971977878737

c_3 = 64864977037231624991423831965394304787965838591735479931470076118956460041888044329021534008265748308238833071879576193558419510910272917201870797698253331425756509041685848066195410586013190421426307862029999566951239891512032198024716311786896333047799598891440799810584167402219122283692655717691362258659

n_1 = 147896270072551360195753454363282299426062485174745759351211846489928910241753224819735285744845837638083944350358908785909584262132415921461693027899236186075383010852224067091477810924118719861660629389172820727449033189259975221664580227157731435894163917841980802021068840549853299166437257181072372761693

n_2 = 95979365485314068430194308015982074476106529222534317931594712046922760584774363858267995698339417335986543347292707495833182921439398983540425004105990583813113065124836795470760324876649225576921655233346630422669551713602423987793822459296761403456611062240111812805323779302474406733327110287422659815403

n_3 = 95649308318281674792416471616635514342255502211688462925255401503618542159533496090638947784818456347896833168508179425853277740290242297445486511810651365722908240687732315319340403048931123530435501371881740859335793804194315675972192649001074378934213623075830325229416830786633930007188095897620439987817
```

### Final Solution
```python
#!/usr/bin/python3
from sympy import mod_inverse, cbrt, Integer
from Crypto.Util.number import long_to_bytes
# Define the constants
e = 3
c_1 = 105001824161664003599422656864176455171381720653815905925856548632486703162518989165039084097502312226864233302621924809266126953771761669365659646250634187967109683742983039295269237675751525196938138071285014551966913785883051544245059293702943821571213612968127810604163575545004589035344590577094378024637
c_2 = 31631442837619174301627703920800905351561747632091670091370206898569727230073839052473051336225502632628636256671728802750596833679629890303700500900722642779064628589492559614751281751964622696427520120657753178654351971238020964729065716984136077048928869596095134253387969208375978930557763221971977878737
c_3 = 64864977037231624991423831965394304787965838591735479931470076118956460041888044329021534008265748308238833071879576193558419510910272917201870797698253331425756509041685848066195410586013190421426307862029999566951239891512032198024716311786896333047799598891440799810584167402219122283692655717691362258659
n_1 = 147896270072551360195753454363282299426062485174745759351211846489928910241753224819735285744845837638083944350358908785909584262132415921461693027899236186075383010852224067091477810924118719861660629389172820727449033189259975221664580227157731435894163917841980802021068840549853299166437257181072372761693
n_2 = 95979365485314068430194308015982074476106529222534317931594712046922760584774363858267995698339417335986543347292707495833182921439398983540425004105990583813113065124836795470760324876649225576921655233346630422669551713602423987793822459296761403456611062240111812805323779302474406733327110287422659815403
n_3 = 95649308318281674792416471616635514342255502211688462925255401503618542159533496090638947784818456347896833168508179425853277740290242297445486511810651365722908240687732315319340403048931123530435501371881740859335793804194315675972192649001074378934213623075830325229416830786633930007188095897620439987817
# Multiplication function for list of numbers
def mul(lst):
    ret = 1
    for n in lst:
        ret *= n
    return ret
# Chinese Remainder Theorem function
def crt(C, N):
    assert len(C) == len(N)
    total = 0
    modulo = mul(N)
    for n_i, c_i in zip(N, C):
        p = modulo // n_i
        total += c_i * mod_inverse(p, n_i) * p
    return total % modulo
# Cube root function
def third_root(n):
    m = cbrt(Integer(n))
    print("Cleartext:", long_to_bytes(int(m)).decode())
    print("Integer: ", int(m))
# Ciphertexts and Moduli
C = [c_1, c_2, c_3]
N = [n_1, n_2, n_3]
# Calculate x using CRT
x = crt(C, N)
# Find the cube root of x
third_root(x)
```

```python
python3 solve.py
Cleartext: DUCTF{btw_y0u_c4n_als0_us3_CRT_f0r_p4rt14l_fr4ct10ns}
Integer:  11564025922867522871782912815123211630478650327759091593792994457296772521676766420142199669845768991886967888274582504750347133
```

Answer:
`DUCTF{btw_y0u_c4n_als0_us3_CRT_f0r_p4rt14l_fr4ct10ns}`

