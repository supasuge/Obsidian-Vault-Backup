## Table of Contents

- [Coding Basics](#coding\basics)
      - [Declaring a Structure](#Declaring\a\Structure)
      - [Initializing and Accessing Structures Members](#Initializing\and\Accessing\Structures\Members)
      - [Right and Left Shift](#Right\and\Left\Shift)
      - [Bitwise OR](#Bitwise\OR)
      - [Bitwise AND](#Bitwise\AND)
      - [Bitwise XOR](#Bitwise\XOR)
      - [Bitwise NOT](#Bitwise\NOT)
    - [Passing By Value](#Passing\By\Value)
    - [Passing By Reference](#Passing\By\Reference)

- [Visual Studio](https://visualstudio.microsoft.com/) - This is the development environment where the coding & compiling process will occur. Install the C/C++ Runtime.
    
- [x64dbg](https://x64dbg.com/) - x64dbg is a debugger that will be used throughout the modules to get an internal understanding of the developed malware.
    
- [PE-Bear](https://github.com/hasherezade/pe-bear) - PE-bear is a multiplatform reversing tool for PE files. It will also be used to assess the developed malware and look for suspicious indicators.
    
- [Process Hacker 2](https://processhacker.sourceforge.io/downloads.php) - Process Hacker is a powerful, multi-purpose tool that helps monitor system resources, debug software and detect malware.
    
- [Msfvenom](https://www.offensive-security.com/metasploit-unleashed/msfvenom/)

# Coding Basics

```C
typedef struct tagTHREADENTRY32 {
DWORD dwSize;
DWORD cntUsage; // Member 2
DWORD th32ThreadID;
DWORD th32OwnerProcessID;
LONG  tpBasePri;
LONG  tpDeltaPri;
DWORD dwFlags;
}
```




#### Declaring a Structure

Structures used in this course are generally declared with the use of `typedef` keyword to give a structure an alias. For example, the structure below is created with the name `_STRUCTURE_NAME` but `typedef` adds two other names, `STRUCTURE_NAME` and `*PSTRUCTURE_NAME`.

```c
typedef struct _STRUCTURE_NAME {

  // structure elements

} STRUCTURE_NAME, *PSTRUCTURE_NAME;
```

The `STRUCTURE_NAME` alias refers to the structure name, whereas `PSTRUCTURE_NAME` represents a pointer to that structure. Microsoft generally uses the `P` prefix to indicate a pointer type.

#### Initializing and Accessing Structures Members

A structure's members can be initialized either directly through the structure or indirectly through a pointer to the structure. In the example below, the structure `struct1` has two members, `ID` and `Age`, initialized directly via the dot operator (`.`).

```c
typedef struct _STRUCTURE_NAME {
  int ID;
  int Age;
} STRUCTURE_NAME, *PSTRUCTURE_NAME;

STRUCTURE_NAME struct1 = { 0 }; // initialize all elements of struct1 to zero
struct1.ID   = 1470;   // initialize the ID element
struct1.Age  = 34;     // initialize the Age element
```

Another way to initialize the members is using _designated initializer syntax_ where one can specify which members of the structure to initialize.

```c
typedef struct _STRUCTURE_NAME {
  int ID;
  int Age;
} STRUCTURE_NAME, *PSTRUCTURE_NAME;

STRUCTURE_NAME struct1 = { .ID   = 1470,  .Age  = 34}; // initialize both the ID and the Age elements
```

On the other hand, accessing and initializing a structure through its pointer is done via the arrow operator (`->`).

```c
typedef struct _STRUCTURE_NAME {
  int ID;
  int Age;
} STRUCTURE_NAME, *PSTRUCTURE_NAME;

STRUCTURE_NAME struct1 = { .ID   = 1470,  .Age  = 34};

PSTRUCTURE_NAME structpointer = &struct1; // structpointer is a pointer to the 'struct1' structure

// Updating the ID member
structpointer->ID = 8765;
printf("The structure's ID member is now : %d \n", structpointer->ID);
```

The arrow operator can be converted into dot format. For example, `structpointer->ID` is equivalent to `(*structpointer).ID`. That is, `structurepointer` is de-referenced and then accessed directly.
#### Right and Left Shift

The right shift (`>>`) and left shift (`<<`) operators are used to shift the bits of a binary number to the right and left by a specified number of positions, respectively.

Shifting right discards the rightmost number of bits by the specified value and zero bits of the same amount are inserted into the left. For example, the image below shows `10100111` shifted right by `2`, to become `00101001`.

![image](https://user-images.githubusercontent.com/111295429/233790472-9782abea-7104-4f8f-b927-5ee0e74e8424.png)

On the other hand, shifting left discards the leftmost bits and the same number of zero bits are inserted from the right handside. For example, the image below shows `10100111` shifted left by `2`, to become `10011100`.

![image](https://user-images.githubusercontent.com/111295429/233791839-6d230e61-7f27-43f3-95a2-dbd1ead75b6f.png)

#### Bitwise OR

The bitwise OR operation is a logical operation that involves two binary values at the bit level. It evaluates each bit of the first operand against the corresponding bit of the second operand, generating a new binary value. The new binary value contains a 1 in any bit position where either one or both of the corresponding bits in the original values are 1.

The following table represents the bitwise OR output with all the possible input bits.

![image](https://user-images.githubusercontent.com/111295429/233792537-7fe6b3df-a217-4a7a-bae8-a20e1c86be0f.png)

#### Bitwise AND

The bitwise AND operation is a logical operation that involves two binary values at the bit level. This operation sets the bits of the new binary value to 1 only in the case where the corresponding bits of both input operands are 1.

The following table represents the bitwise AND output with all the possible input bits.

![image](https://user-images.githubusercontent.com/111295429/233792744-d6e10278-323c-48f0-8740-7f2ad579a71c.png)

#### Bitwise XOR

The bitwise XOR operation (also known as exclusive OR) is a logical operation that involves two binary values at the bit level. If only one of the bits is 1, the result in each position is 1. Conversely, if both bits are 0 or 1, the output is 0.

The following table represents the bitwise XOR output with all the possible input bits.

![image](https://user-images.githubusercontent.com/111295429/233793118-743398f2-e21c-441c-bb79-a80fe7876719.png)

#### Bitwise NOT

The bitwise NOT operation takes one binary number and flips all its bits. In other words, it changes all 0s to 1s and all 1s to 0s. The following table represents the bitwise NOT output with all the possible input bits.

![image](https://user-images.githubusercontent.com/111295429/233794817-82f48b9f-8770-413c-b4e3-b16697adcac6.png)

### Passing By Value

Passing by value is a method of passing arguments to a function where the argument is a copy of the object's value. This means that when an argument is passed by value, the value of the object is copied and the function can only modify its local copy of the object's value, not the original object itself.

```c
int add(int a, int b)
{
   int result = a + b;
   return result;
}

int main()
{
   int x = 5;
   int y = 10;
   int sum = add(x, y); // x and y are passed by value

   return 0;
}
```

### Passing By Reference

Passing by reference is a method of passing arguments to a function where the argument is a pointer to the object, rather than a copy of the object's value. This means that when an argument is passed by reference, the memory address of the object is passed instead of the value of the object. The function can then access and modify the object directly, without creating a local copy of the object.

```c
void add(int *a, int *b, int *result)
{
  
  int A = *a; // A is now the same value of a passed in from the main function
  int B = *b; // B is now the same value of b passed in from the main function
  
  *result = B + A;
}

int main()
{
   int x = 5;
   int y = 10;
   int sum = 0;

   add(&x, &y, &sum);
  
   // 'sum' now is 15
   
   return 0;
}
```

1. **User Processes** - A program/application executed by the user such as Notepad, Google Chrome or Microsoft Word.
    
2. **Subsystem DLLs** - DLLs that contain API functions that are called by user processes. An example of this would be `kernel32.dll` exporting the [CreateFile](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea) Windows API (WinAPI) function, other common subsystem DLLs are `ntdll.dll`, `advapi32.dll`, and `user32.dll`.
    
3. **Ntdll.dll** - A system-wide DLL which is the lowest layer available in user mode. This is a special DLL that creates the transition from user mode to kernel mode. This is often referred to as the Native API or NTAPI.
    
4. **Executive Kernel** - This is what is known as the Windows Kernel and it calls other drivers and modules available within kernel mode to complete tasks. The Windows kernel is partially stored in a file called `ntoskrnl.exe` under "C:\Windows\System32".
5. 