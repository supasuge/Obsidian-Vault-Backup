## Table of Contents

    - [DLL (Dynamic Link Library)](#DLL\(Dynamic\Link\Library))
      - [Definition](#Definition)
      - [Purpose & Characteristics](#Purpose\&\Characteristics)
      - [Default DLLs](#Default\DLLs)
    - [Why Use DLLs?](#Why\Use\DLLs?)
    - [DLL Entry Point](#DLL\Entry\Point)
    - [Sample DLL Code](#Sample\DLL\Code)
    - [Exporting a Function](#Exporting\a\Function)
    - [Dynamic Linking](#Dynamic\Linking)
      - [Loading a DLL](#Loading\a\DLL)
      - [Retrieving a DLL's Handle](#Retrieving\a\DLL's\Handle)
    - [Using a DLL's Exported Function](#Using\a\DLL's\Exported\Function)
      - [Retrieving a Function's Address](#Retrieving\a\Function's\Address)
      - [Invoking the Function](#Invoking\the\Function)
    - [Unloading a DLL](#Unloading\a\DLL)
    - [Summary](#Summary)
      - [Retrieving a Function's Address](#Retrieving\a\Function's\Address)
      - [Invoking The Function](#Invoking\The\Function)
    - [Dynamic Linking Example](#Dynamic\Linking\Example)
    - [Function Pointers](#Function\Pointers)
    - [Rundll32.exe](#Rundll32.exe)
    - [Creating a DLL File With Visual Studio](#Creating\a\DLL\File\With\Visual\Studio)

Both `.exe` and `.dll` file types are considered portable executable formats but there are differences between the two

### DLL (Dynamic Link Library)

#### Definition

- DLLs are shared libraries containing executable functions or data.

#### Purpose & Characteristics

- **Shared Usage**: Can be used by multiple applications at the same time.
- **Export Functions**: Used to make functions available for a process.
- **Non-Executable**: Unlike EXE files, DLLs can't run on their own. They need to be called by other programs.
- **Example**: `CreateFileW` is exported from `kernel32.dll`. To use this function, a process must load `kernel32.dll` into its address space.

#### Default DLLs

- Some DLLs are loaded into every process by default.
- They provide essential functions for proper execution.
- **Examples**: `ntdll.dll`, `kernel32.dll`, `kernelbase.dll`.

The Windows OS uses a system-wide DLL base address to load some DLLs at the same base address in the virtual address space of all processes on a given machine to optimize memory usage and improve system performance. The following image shows `kernel32.dll` being loaded at the same address (`0x7fff9fad0000`) among multiple running processes.

### Why Use DLLs?

There are several reasons why DLLs are very often used in Windows:

1. **Modularization of Code** - Instead of having one massive executable that contains the entire functionality, the code is divided into several independent libraries with each library being focused on specific functionality. Modularization makes it easier for developers during development and debugging.
2. **Code Reuse** - DLLs promote code reuse since a library can be invoked by multiple processes.
3. **Efficient Memory Usage** - When several processes need the same DLL, they can save memory by sharing that DLL instead of loading it into the process's memory.

### DLL Entry Point

DLLs can optionally specify an entry point function that executes code when a certain task occurs such as when a process loads the DLL library. There are 4 possibilities for the entry point being called:

- `DLL_PROCESS_ATTACH` - A process is loading the DLL.
- `DLL_THREAD_ATTACH` - A process is creating a new thread.
- `DLL_THREAD_DETACH` - A thread exits normally.
- `DLL_PROCESS_DETACH` - A process unloads the DLL.
### Sample DLL Code

The code below shows a typical DLL code structure.

```c
BOOL APIENTRY DllMain(
    HANDLE hModule,             // Handle to DLL module
    DWORD ul_reason_for_call,   // Reason for calling function
    LPVOID lpReserved           // Reserved
) {
    
    switch (ul_reason_for_call) {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        // Do something here
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        // Do something here
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        // Do something here
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        // Do something here
        break;
    }
    return TRUE;
}
```

### Exporting a Function

DLLs can export functions that can then be used by the calling application or process. To export a function it needs to be defined using the keywords `extern` and `__declspec(dllexport)`. An example exported function `HelloWorld` is shown below.

```c
////// sampleDLL.dll //////

extern __declspec(dllexport) void HelloWorld(){
// Function code here
}
```

### Dynamic Linking

It's possible to use the `LoadLibrary`, `GetModuleHandle` and `GetProcAddress` WinAPIs to import a function from a DLL. This is referred to as [dynamic linking](https://learn.microsoft.com/en-us/windows/win32/dlls/run-time-dynamic-linking). This is a method of loading and linking code (DLLs) at runtime rather than linking them at compile time using the linker and import address table.

There are several advantages of using dynamic linking, these are documented by Microsoft [here](https://learn.microsoft.com/en-us/windows/win32/dlls/advantages-of-dynamic-linking).

This section walks through the steps of loading a DLL, retrieving the DLL's handle, retrieving the exported function's address and then invoking the function.

#### Loading a DLL

Calling a function such as [MessageBoxA](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxa) in an application will force the Windows OS to load the DLL exporting the `MessageBoxA` function into the calling process's memory address space, which in this case is `user32.dll`. Loading `user32.dll` was done automatically by the OS when the process started and not by the code.

However, in some cases such as the `HelloWorld` function in `sampleDLL.dll`, the DLL may not be loaded into memory. For the application to call the `HelloWorld` function, it first needs to retrieve the DLL's handle that is exporting the function. If the application doesn't have `sampleDLL.dll` loaded into memory, it would require the usage of the [LoadLibrary](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) WinAPI, as shown below.

```c
HMODULE hModule = LoadLibraryA("sampleDLL.dll"); // hModule now contain sampleDLL.dll's handle
```

#### Retrieving a DLL's Handle

If `sampleDLL.dll` is already loaded into the application's memory, one can retrieve its handle via the [GetModuleHandle](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea) WinAPI function without leveraging the `LoadLibrary` function.

```c
HMODULE hModule = GetModuleHandleA("sampleDLL.dll");
```
### Using a DLL's Exported Function

Once the DLL is loaded and you have its handle, the next step is to get the address of the exported function you want to use. This is achieved using the `GetProcAddress` WinAPI.

#### Retrieving a Function's Address

The `GetProcAddress` function returns the address of the specified exported dynamic-link library (DLL) function. Here's how you can use it:

cCopy code

`typedef void (*HelloWorldFunction)(); // Define a function pointer type for HelloWorld HelloWorldFunction functionPointer;  functionPointer = (HelloWorldFunction) GetProcAddress(hModule, "HelloWorld");`

In the code above, we first define a function pointer type for our `HelloWorld` function. Then, we retrieve the function's address using `GetProcAddress` and assign it to our function pointer.

#### Invoking the Function

Now that you have the function's address, you can invoke it using the function pointer:

cCopy code

`if (functionPointer != NULL) {     functionPointer(); // Call HelloWorld }`

### Unloading a DLL

After you've finished using the functions in the DLL, it's a good practice to unload it from memory, especially if you loaded it using `LoadLibrary`. This is done using the `FreeLibrary` WinAPI:

cCopy code

`FreeLibrary(hModule);`

### Summary

- **Exporting a Function**: DLLs can define functions using `extern` and `__declspec(dllexport)` to be available for other applications.
- **Dynamic Linking**: Allows loading and linking of DLLs at runtime. Offers flexibility over static linking.
- **Loading a DLL**: `LoadLibrary` loads a DLL into memory. If already loaded, `GetModuleHandle` retrieves its handle.
- **Using a DLL's Function**: `GetProcAddress` retrieves the address of an exported function. This address can then be used to invoke the function.
- **Unloading a DLL**: `FreeLibrary` unloads a DLL from memory after its usage.

#### Retrieving a Function's Address

Once the DLL is loaded into memory and the handle is retrieved, the next step is to retrieve the function's address. This is done using the [GetProcAddress](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) WinAPI which takes the handle of the DLL that exports the function and the function name.

```c
PVOID pHelloWorld = GetProcAddress(hModule, "HelloWorld");
```

#### Invoking The Function

Once `HelloWorld`'s address is saved into the `pHelloWorld` variable, the next step is to perform a type-cast on this address to `HelloWorld`'s function pointer. This function pointer is required in order to invoke the function.

```c
// Constructing a new data type that represents HelloWorld's function pointer 
typedef void (WINAPI* HelloWorldFunctionPointer)();  

void call(){
    HMODULE hModule = LoadLibraryA("sampleDLL.dll");
    PVOID pHelloWorld = GetProcAddress(hModule, "HelloWorld");
    // Type-casting the 'pHelloWorld' variable to be of type 'HelloWorldFunctionPointer' 
    HelloWorldFunctionPointer HelloWorld = (HelloWorldFunctionPointer)pHelloWorld;
    HelloWorld();   // Calling the 'HelloWorld' function via its function pointer 
}
```

### Dynamic Linking Example
The code below demonstrates another simple example of dynamic linking where `MessageBoxA` is called. The code assumes that `user32.dll`, the DLL that exports that function, isn't loaded into memory. Recall that if a DLL isn't loaded into memory the usage of `LoadLibrary` is required to load that DLL into the process's address space.

```c
typedef int (WINAPI* MessageBoxAFunctionPointer)( // Constructing a new data type, that will represent MessageBoxA's function pointer 
  HWND          hWnd,
  LPCSTR        lpText,
  LPCSTR        lpCaption,
  UINT          uType
);

void call(){
    // Retrieving MessageBox's address, and saving it to 'pMessageBoxA' (MessageBoxA's function pointer)
    MessageBoxAFunctionPointer pMessageBoxA = (MessageBoxAFunctionPointer)GetProcAddress(LoadLibraryA("user32.dll"), "MessageBoxA");
    if (pMessageBoxA != NULL){
        // Calling MessageBox via its function pointer if not null    
        pMessageBoxA(NULL, "MessageBox's Text", "MessageBox's Caption", MB_OK); 
    }
}
```
### Function Pointers

For the remainder of the course, the function pointer data types will have a naming convention that uses the WinAPI's name prefixed with `fn`, which stands for "function pointer". For example, the above `MessageBoxAFunctionPointer` data type will be represented as `fnMessageBoxA`. This is used to maintain simplicity and improve clarity throughout the course.

### Rundll32.exe

There are a couple of ways to run exported functions without using a programmatical method. One common technique is to use the [rundll32.exe](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/rundll32) binary. `Rundll32.exe` is a built-in Windows binary that is used to run an exported function of a DLL file. To run an exported function use the following command:

```c
rundll32.exe <dllname>, <function exported to run>
```

For example, `User32.dll` exports the function `LockWorkStation` which locks the machine. To run the function, use the following command:

```c
rundll32.exe user32.dll,LockWorkStation
```
### Creating a DLL File With Visual Studio

To create a DLL file, launch Visual studio and create a new project. When given the project templates, select the `Dynamic-Link Library (DLL)` option.
The provided DLL template comes with `framework.h`, `pch.h` and `pch.cpp` which are known as [Precompiled Headers](https://en.wikipedia.org/wiki/Precompiled_header). These are files used to make the project compilation faster for large projects. It is unlikely that these will be required in this situation and therefore it is recommended to delete these files. To do so, highlight the file and press the delete key and select the 'Delete' option.

![image](https://maldevacademy.s3.amazonaws.com/images/Basic/create-dll-3-1.png)

  

![image](https://maldevacademy.s3.amazonaws.com/images/Basic/create-dll-3.png)

  

After deleting the precompiled headers, the compiler's default settings must be changed to confirm that precompiled headers should not be used in the project.

![image](https://maldevacademy.s3.amazonaws.com/images/Basic/create-dll-4.png)
Go to **C/C++ > Precompiled Header**

![image](https://maldevacademy.s3.amazonaws.com/images/Basic/create-dll-5.png)

  

Change the 'Precompiled Header' option to 'Not Using Precompiled Headers' and press 'Apply'.

![image](https://maldevacademy.s3.amazonaws.com/images/Basic/create-dll-6.png)

  

Finally, change the `dllmain.cpp` file to `dllmain.c`. This is required since the provided code snippets in Maldev Academy use C instead of C++. To compile the program, click Build > Build Solution and a DLL will be created under the _Release_ or _Debug_ folder, depending on the compile configuration.
