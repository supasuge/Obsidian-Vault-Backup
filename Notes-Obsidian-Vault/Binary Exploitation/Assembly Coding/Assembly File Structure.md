## Table of Contents

  - [Table of Contents](#Table\of\Contents)
      - [Hello World in `nasm`](#Hello\World\in\`nasm`)
    - [Three Elements](#Three\Elements)
  - [Directives](#Directives)
  - [Variables](#Variables)
    - [Code](#Code)

## Table of Contents

      - [Hello World in `nasm`](#Hello\World\in\`nasm`)
    - [Three Elements](#Three\Elements)
  - [Directives](#Directives)
  - [Variables](#Variables)
    - [Code](#Code)

The best way to learn assembly is to write code, assemble it, and debug it. In this section, teh basic structure of an Assembly file, and in the following two sections, we will cover assembling 

#### Hello World in `nasm`
```Assembly
	global _start

	section .data
message: db "Hello, world!"
	section.text
_start:
	mov rax, 1
	mov rdi, 1
	mov rsi, messsage
	mov rdx, 13
	syscall

	mov rax, 60
	mov rdi, 0
	syscall

```
First, let's examine the way the code is distributed:

![](https://academy.hackthebox.com/storage/modules/85/nasm_structure.jpg)


### Three Elements
- Labels
- Instructions
- Operands

A label can be defined at each line, often referred to by instructions or directives.

Looking at the code line-by-line, we see that it has three main parts:

|                 |                                                                                                     |
| --------------- | --------------------------------------------------------------------------------------------------- |
| `global _start` | This is a `directive` that directs the code to start executing at the `_start` label defined below. |
| `section .data` | This is the `data` section, which should contain all of the variables.                              |
| `section .text` | This is the `text` section containing all of the code to be executed.                               |
Both the `.data` and `.text` sections refer to the `data` and `text` memory segments, in which these instructions will be stored.

## Directives
	globals
Assembly is line based, the file is processed line by line, executing the instruction of each line. the `directive` `global _start` instructs the machine to start processing the instructions after the `_start` label and executing them. 

## Variables
	.data section
The `data` section holds the variables to make it easier to define variables and reuse them. One the program runs, the variables are loaded into memory in the `data` segment.

We can define variables using `db` for a list of bytes, `dw` for a list of words, `dd` for a list of digits, and so on. We can also label any of our variables so we can call it or reference it later. The following are some examples of defining variables:

|Instruction|Description|
|---|---|
|`db 0x0a`|Defines the byte `0x0a`, which is a new line.|
|`message db 0x41, 0x42, 0x43, 0x0a`|Defines the label `message => abc\n`.|
|`message db "Hello World!", 0x0a`|Defines the label `message => Hello World!\n`.|

Furthermore, we can use the `equ` instruction with the `$` token to evaluate an expression, like the length of a defined variable's string. However, the labels defined with the `equ` instruction are constants, and they cannot be changed later.

For example, the following code defines a variable and then defines a constant for its length:

```nasm
section .data
    message db "Hello World!", 0x0a
    length  equ $-message
```


Note: the `$` token indicates the current distance from the beginning of the current section. As the `message` variable is at the beginning of the `data` section, the current location, i.e,. value of `$`, equals the length of the string. For the scope of this module, we will only use this token to calculate lengths of strings, using the same line of code shown above.


### Code
The second section is the `.text` section, this section holds all the assembly instructions and loads them to the `text` memory segment. Once all instructions are loaded into the `text` segment, the processor starts executing them one after another.

The default convention is to have the `_start` label at the beginning of the `.text` section, which-as per the `global _start` directive-starts the main code that will be executed as the program runs. As we will later see in the module, we can define other labels within the `.text` section, for loops and other functions.

The `text` segment within the memory is read-only, so we cannot write any variables within it. The `data` section on the other hand IS read/write, which is why we write our variables *within* it.

The `text` segment within the memory is read-only, so we cannot write any variables within it. The `data` section, on the other hand, is read/write, which is why we write our variables to it. However, the `data` segment within the memory is not executable, so any code we write to it cannot be executed. This separation is part of memory protections to mitigate things like buffer overflows and other types of binary exploitation.

Tip: We can add comments to our assembly code with a semi-colon `;`. We can use comments to explain the purpose of each part of the code, and what each line is doing. Doing so will save us a lot of time in the future if we ever revisit the code and need to understand it.


**To Define Variables**:
`db`: list of bytes
`dw`: list of words
`dd`: list of digits

You can label variables to be used later like below.

|Instruction|Description|
|---|---|
|`db 0x0a`|Defines the byte `0x0a`, which is a new line.|
|`message db 0x41, 0x42, 0x43, 0x0a`|Defines the label `message => abc\n`.|
|`message db "Hello World!", 0x0a`|Defines the label `message => Hello World!\n`.|

The `equ` instruction with the `$` is used to evaluate an expression, like the length of a defined variable's string. However, the labels defined with the `equ` instruction are constants, and they cannot be changed later

*For example, the following code defines a variable and then defines a constant for its length:*
```nasm
section .data
    message db "Hello World!", 0x0a
    length  equ $-message
```






