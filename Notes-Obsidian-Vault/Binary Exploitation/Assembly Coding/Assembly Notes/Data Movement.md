## Table of Contents

  - [Table of Contents](#Table\of\Contents)
  - [Moving Data](#Moving\Data)
    - [Loading Data](#Loading\Data)
    - [Moving Pointer Values](#Moving\Pointer\Values)
      - [Moving Pointer Values](#Moving\Pointer\Values)

## Table of Contents

  - [Moving Data](#Moving\Data)
    - [Loading Data](#Loading\Data)
    - [Moving Pointer Values](#Moving\Pointer\Values)
      - [Moving Pointer Values](#Moving\Pointer\Values)

| Instruction | Description                                  | Example                                   |
| :---------- | :------------------------------------------- | :---------------------------------------- |
| `mov`       | Move data or load immediate data             | `mov rax, 1` -> `rax=1`                   |
| `lea`       | Load an address pointing to the value        | `lea rax. [rsp+5]` -> `rax = rsp+5`       |
| `xchg`      | Swap data between two registers or addresses | `xchg rax, rbx` -> `rax = rbx, rbx = rax` |
## Moving Data
This is the fibonacci sequence using assembly.
We will need to load the inital valus $F^0$ and $F^1$
```nasm
global _start

section .text
_start:
    mov rax, 0
    mov rbx, 1
```
(`fib.s`)
Note: In assembly, moving data does not affect the source operanc. So, we can consider `mov` as a `copy` function, rather than an actual move.


### Loading Data
We can load immediate adata using the `mov` instruction. For example, we can load the value of `1` into the `rax` register using the `mov rax, 1` instruction. We have to remember here that *the size of the loaded data depends on the size of the destination register*. For example, in the above `mov rax, 1` instruction, since we used the 64-bit register `rax`, it will be moving a 64-bit representation of the number `1` (i.e. `0x00000001`), which is not very efficient.
Let us take the following basic assembly code to compare the disassembly of both instructions:

Code: nasm

```nasm
global  _start

section .text
_start:
    mov rax, 0
	mov rbx, 1
    mov bl, 1
```
Now lets assemble it and view it's shellcode with `objdump`
```bash
nasm -f elf64 fib.s && objdump -M intel -d fib.o

fib.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <_start>:
   0:	b8 00 00 00 00       	mov    eax,0x0
   5:	bb 01 00 00 00       	mov    ebx,0x1
   a:	b3 01                	mov    bl,0x1

```
We can see that the shellcode of the first instruction is more than double the size of the last instruction.

`This understanding will become very handy when writing shellcodes.`


### Moving Pointer Values
```
gdb -q ./fib
gef➤  b _start
Breakpoint 1 at 0x401000
gef➤  r
...SNIP...
$rsp   : 0x00007fffffffe490  →  0x0000000000000001
$rip   : 0x0000000000401000  →  <_start+0> mov eax, 0x0
```

We see that both registers contain pointer addresses to other locations. `GEF` does an excellent job of showing us the final destination value.

#### Moving Pointer Values

We can see that the `rsp` register holds the final value of `0x1`, and its immediate value is a pointer address to `0x1`. So, if we were to use `mov rax, rsp`, we won't be moving the value `0x1` to `rax`, but we will be moving the pointer address `0x00007fffffffe490` to `rax`.

To move the actual value, we will have to use square brackets `[]`, which in `x86_64` assembly and `Intel` syntax means `load value at address`. So, in the same above example, if we wanted to move the final value `rsp` is pointing to, we can wrap `rsp` in square brackets, like `mov rax, [rsp]`, and this `mov` instruction will move the final value rather than the immediate value (which is an address to the final value).