## Table of Contents

  - [Table of Contents](#Table\of\Contents)
- [[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#gdb)GDB](#[](https://github.com/es7evam/security-studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/gdb.md#gdb)gdb)
  - [[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#running-and-disassembling)](#[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#running-and-disassembling))
  - [Running and Disassembling](#Running\and\Disassembling)
  - [[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#gdb-commands)](#[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#gdb-commands))
  - [GDB Commands](#GDB\Commands)
    - [[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#control-flow)](#[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#control-flow))
    - [Control Flow](#Control\Flow)
    - [[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#registers)](#[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#registers))
    - [Registers](#Registers)
- [Registers and Data Types](#registers\and\data\types)
  - [Registers](#Registers)
    - [General Purpose Registers](#General\Purpose\Registers)
    - [Address Registers](#Address\Registers)
    - [Another registers](#Another\registers)
  - [Instruction set](#Instruction\set)
    - [x86](#x86)
    - [ARM](#ARM)
- [Radare 2](#radare\2)
  - [Basics and Running](#Basics\and\Running)
  - [Commands](#Commands)
    - [Control Flow](#Control\Flow)
    - [Visual Mode](#Visual\Mode)
- [Web](#web)

## Table of Contents

- [[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#gdb)GDB](#[](https://github.com/es7evam/security-studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/gdb.md#gdb)gdb)
  - [[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#running-and-disassembling)](#[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#running-and-disassembling))
  - [Running and Disassembling](#Running\and\Disassembling)
  - [[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#gdb-commands)](#[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#gdb-commands))
  - [GDB Commands](#GDB\Commands)
    - [[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#control-flow)](#[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#control-flow))
    - [Control Flow](#Control\Flow)
    - [[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#registers)](#[](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#registers))
    - [Registers](#Registers)
- [Registers and Data Types](#registers\and\data\types)
  - [Registers](#Registers)
    - [General Purpose Registers](#General\Purpose\Registers)
    - [Address Registers](#Address\Registers)
    - [Another registers](#Another\registers)
  - [Instruction set](#Instruction\set)
    - [x86](#x86)
    - [ARM](#ARM)
- [Radare 2](#radare\2)
  - [Basics and Running](#Basics\and\Running)
  - [Commands](#Commands)
    - [Control Flow](#Control\Flow)
    - [Visual Mode](#Visual\Mode)
- [Web](#web)

# [](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#gdb)GDB

gdb stands for GNU Project Debugger.  
It is, as the name says, a debugger, and can be used in reverse engineering in order to disassemble and analyze binary files.

## [](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#running-and-disassembling)

## Running and Disassembling

In order to run it, you must execute:

```
gdb programName
```

So, the default syntax of gdb is AT&T. Since here we mainly use Intel syntax we may change it using

```
set disassembly-flavor intel
```

So, in order to disassemble a function you must use

```
disassemble main
```

It is important to notice that the program will be as it shows in memory, but you can use another software in order to visualize better the control flow of it.

## [](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#gdb-commands)

## GDB Commands

If only `Enter` is pressed the last it is equivalent to typing and running the last command again.

### [](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#control-flow)

### Control Flow

- `run arg1, arg2...`  
           Runs the program and, if provided, with the arguments arg1, arg2, ...
- `break *address`  
           Sets a breakpoint at the given address. Can be used with function name insted of address.
- `del`  
           Removes all the breakpoints
- `si`  
           Step one instruction
- `ni`  
           Like si, but not showing execution of function calls (skipping them).
- `set $eax=x`  
           Sets register (eax for example) with value given 'x'
- `define hook-stop`  
           Define hook of stops, like the example below:

```
define hook-stop
info registers
x/24wx $esp
x/2i $eip
end
```

### [](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#registers)

### Registers

- `info registers`  
           Shows the value at the registers of the given program at that moment
- `x/wx $reg`  
           Prints register "reg" content as hexadecimal
- `x/s $reg`  
           Prints register "reg" content as ascii
- `x/24wx $esp`  
           Prints the stack of the program (24 words)
- `x/2i $eip`  
           Prints the next two instructions.
- `x function`  
           Prints address of function
- `p function`  
           Prints the address and return type of function
- `info proc mappings`  
           Show the map of memory

# Registers and Data Types

Here we'll be studying x86 and x86-64 architecture registers, following mainly Intel Pattern.  
In order to store data in general, the main "thing" we use are registers.


## Registers

At x86 architecture there are eight 32-bit general purpose registers (GPRs), some of them can also be divided into 8 and 16-bit registers.


### General Purpose Registers

|Register|Purpose|16 - Bits|8 Bits|
|---|:-:|:-:|:-:|
|EAX|Acumulator, used for arithmetic operations and to store results|AX|AH-AL|
|EBX|Base register for the stack|-|-|
|ECX|Counter in loops|-|-|
|EDX|Used to store addresses of the data|-|-|


### Address Registers

|Register|Purpose|16 - Bits|
|---|:--|:-:|
|ESI|Source in string/memory operations|SI|
|EDI|Destination in string/memory operations|DI|
|EBP|Base Frame Pointer|BP|
|ESP|Stack Pointer|SP|


### Another registers

|Register|Purpose|16 - Bits|
|---|:--|:-:|
|EIP|Instruction Pointer (Program counter)|-|
|EFLAGS|Store operations - Ex: Flag Zero|-|


## Instruction set

The x86 instruction set are around the data movement between registers and memory, classified in 5 types:

- Immediate to register
- Register to register
- Immediate to memory
- Register to memory and vice versa
- Memory to memory - Only in RISC architectures.


### x86

The focus here will be the Intel syntax.  
AT&T prefixes the register with % and immediates with $, which doesn't happen at Intel. They also add a prefix to the instruction to indicate operation width (long, byte, etc.).  
At Intel syntax the destination come and then the source (op dest source), at AT&T it is the opposite.  
Instructions have variable-lenght (1 to 15 bytes).

x86 uses [] to indicate memory access (similar to ***** at C/C++)  
In order to sum or subtract address inside [] usually is used hexadecimal, for example:  
       mov eax [ecx+10h] - Where the h is used to indicate hexadecimal notation.

- MOV - mov ecx, [eax]  
           Sets ecx = [eax]
    
- ADD - inc dword ptr [eax]  
           Increments value at address eax.
    
- SUB - sub eax, 0x20  
           Subtracts eax by 0x20.
    
- PUSH - push eax  
           Pushes eax at the stack
    
- CMP - cmp eax, ebx  
           if(eax == ebx) Sets eflags;
    
- JNE - jne 0x400086  
           Jumps to given address if eflags was set to equal.
    
- CALL - call 0x400086  
           Jumps to given address and saves current location at stack.
    
- RET - ret  
           Pops the address of the stack and returns control to that location - ("jump").
    
- LEA - lea eax, [esp+0x1c]  
           Moves address of register to another (eax = esp+0x1c), used to pass parameters
    
- LEAVE - leave  
           Moves ebp to esp and pops ebp from the stack.
    
### ARM

- Load Word - `LDR R3, [R3]`  
           Read the value at address R3.
- Store Word - `STR R2, [R3]`  
           Store the value from R2 at address R3.
- Add to register - `ADDS R2, R3, #1`        Add 1 to R3 and store at R2.



# Radare 2

"R2" is a rewrite from scratch of radare in order to provide a set of libraries and tools to work with binary files.

## Basics and Running

In order to run Radare

```
r2 programName
```

Start radare with -d flag to debug like gdb.  

Like in vim, you can enter command mode with :

## Commands

- ?  
           Get information about characters you can use (also works like a?)
    
- aaa  
           Automatically analyse and autoname functions.
    
- afl  
           Print every function radare found.
    
- s   `newLocation`  
           Change current location to newLocation (example sym.main).
    
- pdf  
           Print the disassembly of current function.
    
- VV  
           Enter visual mode, showing control graph
    

### Control Flow

When running the control flow you will notice that rip (instruction pointer register is at the execution)

|Command|Action|Example|
|:-:|:--|:-:|
|`db address`|Sets breakpoint at address|`db 0x004005bd`|
|`dc`|Runs the program|-|
|`s`|Step to next instruction|-|
|`S`|Step to next non-library function|-|
|`dr`|Show what is in registers|-|
|`ood`|Reload file in debug mode|-|
|`dr reg=value`|Sets reg to value|`dr=rip0x0040064b`|
|`afvn prevName newName`|Renames variable|`afvn local_2_4 sum`|
|`V!`|Change to complete info grid|-|

### Visual Mode

|Command|Action|
|:-:|:--|
|`tab` and `shift+tab`|select blocks|
|`shift+hjkl`|move the block|
|`p`|Cycle within different representations (with or without address in beginning for example)|
|`?`|Show Help|
|`shift + r`|change colors|
# Web

Web is usually the entry point at security in general.  

Here I'll be mainly covering some tools that can help you when you do things related to web pentesting.  

In the future I plan to write a guide on what you should usually do in each situation, but remember that's not a rule.

