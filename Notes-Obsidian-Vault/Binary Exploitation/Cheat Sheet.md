## Table of Contents

  - [Table of Contents](#Table\of\Contents)
- [[GDB](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#gdb)](#[gdb](https://github.com/es7evam/security-studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/gdb.md#gdb))
  - [Running and Disassembling](#Running\and\Disassembling)
  - [GDB Commands](#GDB\Commands)
    - [Control Flow](#Control\Flow)
    - [Registers](#Registers)
- [Registers and Data Types](#registers\and\data\types)
  - [Registers](#Registers)
    - [General Purpose Registers](#General\Purpose\Registers)
    - [Address Registers](#Address\Registers)
    - [Another registers](#Another\registers)
  - [Instruction set](#Instruction\set)
    - [x86](#x86)
    - [ARM](#ARM)
- [Radare 2](#radare\2)
  - [Basics and Running](#Basics\and\Running)
  - [Commands](#Commands)
    - [Control Flow](#Control\Flow)
    - [Visual Mode](#Visual\Mode)

## Table of Contents

- [[GDB](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#gdb)](#[gdb](https://github.com/es7evam/security-studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/gdb.md#gdb))
  - [Running and Disassembling](#Running\and\Disassembling)
  - [GDB Commands](#GDB\Commands)
    - [Control Flow](#Control\Flow)
    - [Registers](#Registers)
- [Registers and Data Types](#registers\and\data\types)
  - [Registers](#Registers)
    - [General Purpose Registers](#General\Purpose\Registers)
    - [Address Registers](#Address\Registers)
    - [Another registers](#Another\registers)
  - [Instruction set](#Instruction\set)
    - [x86](#x86)
    - [ARM](#ARM)
- [Radare 2](#radare\2)
  - [Basics and Running](#Basics\and\Running)
  - [Commands](#Commands)
    - [Control Flow](#Control\Flow)
    - [Visual Mode](#Visual\Mode)

# [GDB](https://github.com/Es7evam/Security-Studies/blob/c2582d3cae736dd0a22e16cdc167c8db55dc1352/reverse-engineering/GDB.md#gdb)
**gdb** stands for GNU Project Debugger.  
It is, as the name says, a debugger, and can be used in reverse engineering in order to disassemble and analyze binary files.
## Running and Disassembling

In order to run it, you must execute:

```
gdb programName
```

So, the default syntax of gdb is AT&T. Since here we mainly use Intel syntax we may change it using

```
set disassembly-flavor intel
```

So, in order to disassemble a function you must use

```
disassemble main
```

It is important to notice that the program will be as it shows in memory, but you can use another software in order to visualize better the control flow of it.

## GDB Commands

If only `Enter` is pressed the last it is equivalent to typing and running the last command again.


### Control Flow

- `run arg1, arg2...`  
           Runs the program and, if provided, with the arguments arg1, arg2, ...
- `break *address`  
           Sets a breakpoint at the given address. Can be used with function name insted of address.
- `del`  
           Removes all the breakpoints
- `si`  
           Step one instruction
- `ni`  
           Like si, but not showing execution of function calls (skipping them).
- `set $eax=x`  
           Sets register (eax for example) with value given 'x'
- `define hook-stop`  
           Define hook of stops, like the example below:

```
define hook-stop
info registers
x/24wx $esp
x/2i $eip
end
```


### Registers

- `info registers`  
           Shows the value at the registers of the given program at that moment
- `x/wx $reg`  
           Prints register "reg" content as hexadecimal
- `x/s $reg`  
           Prints register "reg" content as ascii
- `x/24wx $esp`  
           Prints the stack of the program (24 words)
- `x/2i $eip`  
           Prints the next two instructions.
- `x function`  
           Prints address of function
- `p function`  
           Prints the address and return type of function
- `info proc mappings`  
           Show the map of memory

# Registers and Data Types

Here we'll be studying x86 and x86-64 architecture registers, following mainly Intel Pattern.  
In order to store data in general, the main "thing" we use are registers.


## Registers

At x86 architecture there are eight 32-bit general purpose registers (GPRs), some of them can also be divided into 8 and 16-bit registers.


### General Purpose Registers

|Register|Purpose|16 - Bits|8 Bits|
|---|:-:|:-:|:-:|
|EAX|Acumulator, used for arithmetic operations and to store results|AX|AH-AL|
|EBX|Base register for the stack|-|-|
|ECX|Counter in loops|-|-|
|EDX|Used to store addresses of the data|-|-|


### Address Registers

|Register|Purpose|16 - Bits|
|---|:--|:-:|
|ESI|Source in string/memory operations|SI|
|EDI|Destination in string/memory operations|DI|
|EBP|Base Frame Pointer|BP|
|ESP|Stack Pointer|SP|


### Another registers

|Register|Purpose|16 - Bits|
|---|:--|:-:|
|EIP|Instruction Pointer (Program counter)|-|
|EFLAGS|Store operations - Ex: Flag Zero|-|


## Instruction set

The x86 instruction set are around the data movement between registers and memory, classified in 5 types:

- Immediate to register
- Register to register
- Immediate to memory
- Register to memory and vice versa
- Memory to memory - Only in RISC architectures.


### x86

The focus here will be the Intel syntax.  
AT&T prefixes the register with % and immediates with $, which doesn't happen at Intel. They also add a prefix to the instruction to indicate operation width (long, byte, etc.).  
At Intel syntax the destination come and then the source (op dest source), at AT&T it is the opposite.  
Instructions have variable-lenght (1 to 15 bytes).

x86 uses [] to indicate memory access (similar to ***** at C/C++)  
In order to sum or subtract address inside [] usually is used hexadecimal, for example:  
       mov eax [ecx+10h] - Where the h is used to indicate hexadecimal notation.

- MOV - mov ecx, [eax]  
           Sets ecx = [eax]
    
- ADD - inc dword ptr [eax]  
           Increments value at address eax.
    
- SUB - sub eax, 0x20  
           Subtracts eax by 0x20.
    
- PUSH - push eax  
           Pushes eax at the stack
    
- CMP - cmp eax, ebx  
           if(eax == ebx) Sets eflags;
    
- JNE - jne 0x400086  
           Jumps to given address if eflags was set to equal.
    
- CALL - call 0x400086  
           Jumps to given address and saves current location at stack.
    
- RET - ret  
           Pops the address of the stack and returns control to that location - ("jump").
    
- LEA - lea eax, [esp+0x1c]  
           Moves address of register to another (eax = esp+0x1c), used to pass parameters
    
- LEAVE - leave  
           Moves ebp to esp and pops ebp from the stack.
    
### ARM

- Load Word - `LDR R3, [R3]`  
           Read the value at address R3.
- Store Word - `STR R2, [R3]`  
           Store the value from R2 at address R3.
- Add to register - `ADDS R2, R3, #1`        Add 1 to R3 and store at R2.



# Radare 2

"R2" is a rewrite from scratch of radare in order to provide a set of libraries and tools to work with binary files.

## Basics and Running

In order to run Radare

```
r2 programName
```

Start radare with -d flag to debug like gdb.  

Like in vim, you can enter command mode with :

## Commands

- ?  
           Get information about characters you can use (also works like a?)
    
- aaa  
           Automatically analyse and autoname functions.
    
- afl  
           Print every function radare found.
    
- s   `newLocation`  
           Change current location to newLocation (example sym.main).
    
- pdf  
           Print the disassembly of current function.
    
- VV  
           Enter visual mode, showing control graph
    

### Control Flow

When running the control flow you will notice that rip (instruction pointer register is at the execution)

|Command|Action|Example|
|:-:|:--|:-:|
|`db address`|Sets breakpoint at address|`db 0x004005bd`|
|`dc`|Runs the program|-|
|`s`|Step to next instruction|-|
|`S`|Step to next non-library function|-|
|`dr`|Show what is in registers|-|
|`ood`|Reload file in debug mode|-|
|`dr reg=value`|Sets reg to value|`dr=rip0x0040064b`|
|`afvn prevName newName`|Renames variable|`afvn local_2_4 sum`|
|`V!`|Change to complete info grid|-|

### Visual Mode

|Command|Action|
|:-:|:--|
|`tab` and `shift+tab`|select blocks|
|`shift+hjkl`|move the block|
|`p`|Cycle within different representations (with or without address in beginning for example)|
|`?`|Show Help|
|`shift + r`|change colors|
